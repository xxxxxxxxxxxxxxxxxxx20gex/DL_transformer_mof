# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Chemistry::OpenBabel;
use base qw(Exporter);
use base qw(DynaLoader);
package Chemistry::OpenBabelc;
bootstrap Chemistry::OpenBabel;
package Chemistry::OpenBabel;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Chemistry::OpenBabel;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Chemistry::OpenBabel;

*toAliasData = *Chemistry::OpenBabelc::toAliasData;
*toAngleData = *Chemistry::OpenBabelc::toAngleData;
*toCommentData = *Chemistry::OpenBabelc::toCommentData;
*toConformerData = *Chemistry::OpenBabelc::toConformerData;
*toExternalBondData = *Chemistry::OpenBabelc::toExternalBondData;
*toGridData = *Chemistry::OpenBabelc::toGridData;
*toMatrixData = *Chemistry::OpenBabelc::toMatrixData;
*toNasaThermoData = *Chemistry::OpenBabelc::toNasaThermoData;
*toPairData = *Chemistry::OpenBabelc::toPairData;
*toRateData = *Chemistry::OpenBabelc::toRateData;
*toRotamerList = *Chemistry::OpenBabelc::toRotamerList;
*toRotationData = *Chemistry::OpenBabelc::toRotationData;
*toSerialNums = *Chemistry::OpenBabelc::toSerialNums;
*toSetData = *Chemistry::OpenBabelc::toSetData;
*toSymmetryData = *Chemistry::OpenBabelc::toSymmetryData;
*toTorsionData = *Chemistry::OpenBabelc::toTorsionData;
*toUnitCell = *Chemistry::OpenBabelc::toUnitCell;
*toVectorData = *Chemistry::OpenBabelc::toVectorData;
*toVibrationData = *Chemistry::OpenBabelc::toVibrationData;
*toVirtualBond = *Chemistry::OpenBabelc::toVirtualBond;
*rotate_coords = *Chemistry::OpenBabelc::rotate_coords;
*calc_rms = *Chemistry::OpenBabelc::calc_rms;
*__lshift__ = *Chemistry::OpenBabelc::__lshift__;
*__add__ = *Chemistry::OpenBabelc::__add__;
*__sub__ = *Chemistry::OpenBabelc::__sub__;
*__div__ = *Chemistry::OpenBabelc::__div__;
*__mul__ = *Chemistry::OpenBabelc::__mul__;
*dot = *Chemistry::OpenBabelc::dot;
*cross = *Chemistry::OpenBabelc::cross;
*vectorAngle = *Chemistry::OpenBabelc::vectorAngle;
*CalcTorsionAngle = *Chemistry::OpenBabelc::CalcTorsionAngle;
*Point2PlaneSigned = *Chemistry::OpenBabelc::Point2PlaneSigned;
*Point2Plane = *Chemistry::OpenBabelc::Point2Plane;
*Point2PlaneAngle = *Chemistry::OpenBabelc::Point2PlaneAngle;
*Point2Line = *Chemistry::OpenBabelc::Point2Line;
*Tanimoto = *Chemistry::OpenBabelc::Tanimoto;
*OBReleaseVersion = *Chemistry::OpenBabelc::OBReleaseVersion;
*ThrowError = *Chemistry::OpenBabelc::ThrowError;
*CartesianToInternal = *Chemistry::OpenBabelc::CartesianToInternal;
*InternalToCartesian = *Chemistry::OpenBabelc::InternalToCartesian;
*NewExtension = *Chemistry::OpenBabelc::NewExtension;
*get_rmat = *Chemistry::OpenBabelc::get_rmat;
*ob_make_rmat = *Chemistry::OpenBabelc::ob_make_rmat;
*qtrfit = *Chemistry::OpenBabelc::qtrfit;
*superimpose = *Chemistry::OpenBabelc::superimpose;
*CompareRingSize = *Chemistry::OpenBabelc::CompareRingSize;
*SmartsLexReplace = *Chemistry::OpenBabelc::SmartsLexReplace;
*double_array = *Chemistry::OpenBabelc::double_array;
*double_destroy = *Chemistry::OpenBabelc::double_destroy;
*double_set = *Chemistry::OpenBabelc::double_set;
*double_get = *Chemistry::OpenBabelc::double_get;
*rotation_matrix = *Chemistry::OpenBabelc::rotation_matrix;
*rotation_matrix_free = *Chemistry::OpenBabelc::rotation_matrix_free;

############# Class : Chemistry::OpenBabel::VectorInt ##############

package Chemistry::OpenBabel::VectorInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorInt_size;
*get = *Chemistry::OpenBabelc::VectorInt_get;
*set = *Chemistry::OpenBabelc::VectorInt_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorUnsignedInt ##############

package Chemistry::OpenBabel::VectorUnsignedInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorUnsignedInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorUnsignedInt_size;
*get = *Chemistry::OpenBabelc::VectorUnsignedInt_get;
*set = *Chemistry::OpenBabelc::VectorUnsignedInt_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorUnsignedInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorVInt ##############

package Chemistry::OpenBabel::VectorVInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorVInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorVInt_size;
*get = *Chemistry::OpenBabelc::VectorVInt_get;
*set = *Chemistry::OpenBabelc::VectorVInt_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorVInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorDouble ##############

package Chemistry::OpenBabel::VectorDouble;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorDouble(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorDouble_size;
*get = *Chemistry::OpenBabelc::VectorDouble_get;
*set = *Chemistry::OpenBabelc::VectorDouble_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorDouble($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorString ##############

package Chemistry::OpenBabel::VectorString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorString(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorString_size;
*get = *Chemistry::OpenBabelc::VectorString_get;
*set = *Chemistry::OpenBabelc::VectorString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorVector3 ##############

package Chemistry::OpenBabel::VectorVector3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorVector3(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorVector3_size;
*get = *Chemistry::OpenBabelc::VectorVector3_get;
*set = *Chemistry::OpenBabelc::VectorVector3_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorVector3($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorOBMol ##############

package Chemistry::OpenBabel::VectorOBMol;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorOBMol(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorOBMol_size;
*get = *Chemistry::OpenBabelc::VectorOBMol_get;
*set = *Chemistry::OpenBabelc::VectorOBMol_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorOBMol($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorOBBond ##############

package Chemistry::OpenBabel::VectorOBBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorOBBond(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorOBBond_size;
*get = *Chemistry::OpenBabelc::VectorOBBond_get;
*set = *Chemistry::OpenBabelc::VectorOBBond_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorOBBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorOBResidue ##############

package Chemistry::OpenBabel::VectorOBResidue;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorOBResidue(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorOBResidue_size;
*get = *Chemistry::OpenBabelc::VectorOBResidue_get;
*set = *Chemistry::OpenBabelc::VectorOBResidue_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorOBResidue($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorOBRing ##############

package Chemistry::OpenBabel::VectorOBRing;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorOBRing(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorOBRing_size;
*get = *Chemistry::OpenBabelc::VectorOBRing_get;
*set = *Chemistry::OpenBabelc::VectorOBRing_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorOBRing($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorpOBRing ##############

package Chemistry::OpenBabel::VectorpOBRing;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorpOBRing(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorpOBRing_size;
*get = *Chemistry::OpenBabelc::VectorpOBRing_get;
*set = *Chemistry::OpenBabelc::VectorpOBRing_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorpOBRing($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::VectorpOBGenericData ##############

package Chemistry::OpenBabel::VectorpOBGenericData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_VectorpOBGenericData(@_);
    bless $self, $pkg if defined($self);
}

*size = *Chemistry::OpenBabelc::VectorpOBGenericData_size;
*get = *Chemistry::OpenBabelc::VectorpOBGenericData_get;
*set = *Chemistry::OpenBabelc::VectorpOBGenericData_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_VectorpOBGenericData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBGlobalDataBase ##############

package Chemistry::OpenBabel::OBGlobalDataBase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBGlobalDataBase(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBGlobalDataBase($self);
        delete $OWNER{$self};
    }
}

*Init = *Chemistry::OpenBabelc::OBGlobalDataBase_Init;
*GetSize = *Chemistry::OpenBabelc::OBGlobalDataBase_GetSize;
*SetReadDirectory = *Chemistry::OpenBabelc::OBGlobalDataBase_SetReadDirectory;
*SetEnvironmentVariable = *Chemistry::OpenBabelc::OBGlobalDataBase_SetEnvironmentVariable;
*ParseLine = *Chemistry::OpenBabelc::OBGlobalDataBase_ParseLine;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBAtomHOF ##############

package Chemistry::OpenBabel::OBAtomHOF;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBAtomHOF(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBAtomHOF($self);
        delete $OWNER{$self};
    }
}

*Element = *Chemistry::OpenBabelc::OBAtomHOF_Element;
*Charge = *Chemistry::OpenBabelc::OBAtomHOF_Charge;
*Method = *Chemistry::OpenBabelc::OBAtomHOF_Method;
*Desc = *Chemistry::OpenBabelc::OBAtomHOF_Desc;
*T = *Chemistry::OpenBabelc::OBAtomHOF_T;
*Value = *Chemistry::OpenBabelc::OBAtomHOF_Value;
*Multiplicity = *Chemistry::OpenBabelc::OBAtomHOF_Multiplicity;
*Unit = *Chemistry::OpenBabelc::OBAtomHOF_Unit;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBAtomicHeatOfFormationTable ##############

package Chemistry::OpenBabel::OBAtomicHeatOfFormationTable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGlobalDataBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBAtomicHeatOfFormationTable(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBAtomicHeatOfFormationTable($self);
        delete $OWNER{$self};
    }
}

*GetHeatOfFormation = *Chemistry::OpenBabelc::OBAtomicHeatOfFormationTable_GetHeatOfFormation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBTypeTable ##############

package Chemistry::OpenBabel::OBTypeTable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGlobalDataBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBTypeTable(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBTypeTable($self);
        delete $OWNER{$self};
    }
}

*SetFromType = *Chemistry::OpenBabelc::OBTypeTable_SetFromType;
*SetToType = *Chemistry::OpenBabelc::OBTypeTable_SetToType;
*Translate = *Chemistry::OpenBabelc::OBTypeTable_Translate;
*GetFromType = *Chemistry::OpenBabelc::OBTypeTable_GetFromType;
*GetToType = *Chemistry::OpenBabelc::OBTypeTable_GetToType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBResidueData ##############

package Chemistry::OpenBabel::OBResidueData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGlobalDataBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBResidueData(@_);
    bless $self, $pkg if defined($self);
}

*SetResName = *Chemistry::OpenBabelc::OBResidueData_SetResName;
*LookupBO = *Chemistry::OpenBabelc::OBResidueData_LookupBO;
*LookupType = *Chemistry::OpenBabelc::OBResidueData_LookupType;
*AssignBonds = *Chemistry::OpenBabelc::OBResidueData_AssignBonds;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBResidueData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBStopwatch ##############

package Chemistry::OpenBabel::OBStopwatch;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Start = *Chemistry::OpenBabelc::OBStopwatch_Start;
*Lap = *Chemistry::OpenBabelc::OBStopwatch_Lap;
*Elapsed = *Chemistry::OpenBabelc::OBStopwatch_Elapsed;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBStopwatch(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBStopwatch($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSqrtTbl ##############

package Chemistry::OpenBabel::OBSqrtTbl;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSqrtTbl(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSqrtTbl($self);
        delete $OWNER{$self};
    }
}

*Sqrt = *Chemistry::OpenBabelc::OBSqrtTbl_Sqrt;
*Init = *Chemistry::OpenBabelc::OBSqrtTbl_Init;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::vector3 ##############

package Chemistry::OpenBabel::vector3;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_vector3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_vector3($self);
        delete $OWNER{$self};
    }
}

*begin = *Chemistry::OpenBabelc::vector3_begin;
*end = *Chemistry::OpenBabelc::vector3_end;
*Set = *Chemistry::OpenBabelc::vector3_Set;
*SetX = *Chemistry::OpenBabelc::vector3_SetX;
*SetY = *Chemistry::OpenBabelc::vector3_SetY;
*SetZ = *Chemistry::OpenBabelc::vector3_SetZ;
*GetX = *Chemistry::OpenBabelc::vector3_GetX;
*GetY = *Chemistry::OpenBabelc::vector3_GetY;
*GetZ = *Chemistry::OpenBabelc::vector3_GetZ;
*Get = *Chemistry::OpenBabelc::vector3_Get;
*idx = *Chemistry::OpenBabelc::vector3_idx;
*AsArray = *Chemistry::OpenBabelc::vector3_AsArray;
*add = *Chemistry::OpenBabelc::vector3_add;
*randomUnitVector = *Chemistry::OpenBabelc::vector3_randomUnitVector;
*normalize = *Chemistry::OpenBabelc::vector3_normalize;
*CanBeNormalized = *Chemistry::OpenBabelc::vector3_CanBeNormalized;
*length_2 = *Chemistry::OpenBabelc::vector3_length_2;
*length = *Chemistry::OpenBabelc::vector3_length;
*x = *Chemistry::OpenBabelc::vector3_x;
*y = *Chemistry::OpenBabelc::vector3_y;
*z = *Chemistry::OpenBabelc::vector3_z;
*__eq__ = *Chemistry::OpenBabelc::vector3___eq__;
*IsApprox = *Chemistry::OpenBabelc::vector3_IsApprox;
*distSq = *Chemistry::OpenBabelc::vector3_distSq;
*createOrthoVector = *Chemistry::OpenBabelc::vector3_createOrthoVector;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::matrix3x3 ##############

package Chemistry::OpenBabel::matrix3x3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_matrix3x3(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_matrix3x3($self);
        delete $OWNER{$self};
    }
}

*GetArray = *Chemistry::OpenBabelc::matrix3x3_GetArray;
*__call__ = *Chemistry::OpenBabelc::matrix3x3___call__;
*inverse = *Chemistry::OpenBabelc::matrix3x3_inverse;
*transpose = *Chemistry::OpenBabelc::matrix3x3_transpose;
*determinant = *Chemistry::OpenBabelc::matrix3x3_determinant;
*isSymmetric = *Chemistry::OpenBabelc::matrix3x3_isSymmetric;
*isOrthogonal = *Chemistry::OpenBabelc::matrix3x3_isOrthogonal;
*isDiagonal = *Chemistry::OpenBabelc::matrix3x3_isDiagonal;
*isUnitMatrix = *Chemistry::OpenBabelc::matrix3x3_isUnitMatrix;
*Get = *Chemistry::OpenBabelc::matrix3x3_Get;
*Set = *Chemistry::OpenBabelc::matrix3x3_Set;
*SetColumn = *Chemistry::OpenBabelc::matrix3x3_SetColumn;
*SetRow = *Chemistry::OpenBabelc::matrix3x3_SetRow;
*GetColumn = *Chemistry::OpenBabelc::matrix3x3_GetColumn;
*GetRow = *Chemistry::OpenBabelc::matrix3x3_GetRow;
*SetupRotMat = *Chemistry::OpenBabelc::matrix3x3_SetupRotMat;
*PlaneReflection = *Chemistry::OpenBabelc::matrix3x3_PlaneReflection;
*RotAboutAxisByAngle = *Chemistry::OpenBabelc::matrix3x3_RotAboutAxisByAngle;
*FillOrth = *Chemistry::OpenBabelc::matrix3x3_FillOrth;
*findEigenvectorsIfSymmetric = *Chemistry::OpenBabelc::matrix3x3_findEigenvectorsIfSymmetric;
*jacobi = *Chemistry::OpenBabelc::matrix3x3_jacobi;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBBitVec ##############

package Chemistry::OpenBabel::OBBitVec;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBBitVec(@_);
    bless $self, $pkg if defined($self);
}

*SetBitOn = *Chemistry::OpenBabelc::OBBitVec_SetBitOn;
*SetBitOff = *Chemistry::OpenBabelc::OBBitVec_SetBitOff;
*SetRangeOn = *Chemistry::OpenBabelc::OBBitVec_SetRangeOn;
*SetRangeOff = *Chemistry::OpenBabelc::OBBitVec_SetRangeOff;
*Fold = *Chemistry::OpenBabelc::OBBitVec_Fold;
*FirstBit = *Chemistry::OpenBabelc::OBBitVec_FirstBit;
*NextBit = *Chemistry::OpenBabelc::OBBitVec_NextBit;
*EndBit = *Chemistry::OpenBabelc::OBBitVec_EndBit;
*GetSize = *Chemistry::OpenBabelc::OBBitVec_GetSize;
*CountBits = *Chemistry::OpenBabelc::OBBitVec_CountBits;
*IsEmpty = *Chemistry::OpenBabelc::OBBitVec_IsEmpty;
*Resize = *Chemistry::OpenBabelc::OBBitVec_Resize;
*ResizeWords = *Chemistry::OpenBabelc::OBBitVec_ResizeWords;
*BitIsSet = *Chemistry::OpenBabelc::OBBitVec_BitIsSet;
*FromVecInt = *Chemistry::OpenBabelc::OBBitVec_FromVecInt;
*FromString = *Chemistry::OpenBabelc::OBBitVec_FromString;
*ToVecInt = *Chemistry::OpenBabelc::OBBitVec_ToVecInt;
*Clear = *Chemistry::OpenBabelc::OBBitVec_Clear;
*Negate = *Chemistry::OpenBabelc::OBBitVec_Negate;
*GetWords = *Chemistry::OpenBabelc::OBBitVec_GetWords;
*add = *Chemistry::OpenBabelc::OBBitVec_add;
*idx = *Chemistry::OpenBabelc::OBBitVec_idx;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBBitVec($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBGenericData ##############

package Chemistry::OpenBabel::OBGenericData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBGenericData(@_);
    bless $self, $pkg if defined($self);
}

*Clone = *Chemistry::OpenBabelc::OBGenericData_Clone;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBGenericData($self);
        delete $OWNER{$self};
    }
}

*SetAttribute = *Chemistry::OpenBabelc::OBGenericData_SetAttribute;
*SetOrigin = *Chemistry::OpenBabelc::OBGenericData_SetOrigin;
*GetAttribute = *Chemistry::OpenBabelc::OBGenericData_GetAttribute;
*GetDataType = *Chemistry::OpenBabelc::OBGenericData_GetDataType;
*GetValue = *Chemistry::OpenBabelc::OBGenericData_GetValue;
*GetOrigin = *Chemistry::OpenBabelc::OBGenericData_GetOrigin;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBBase ##############

package Chemistry::OpenBabel::OBBase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBBase($self);
        delete $OWNER{$self};
    }
}

*Clear = *Chemistry::OpenBabelc::OBBase_Clear;
*DoTransformations = *Chemistry::OpenBabelc::OBBase_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::OBBase_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::OBBase_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::OBBase_SetTitle;
*HasData = *Chemistry::OpenBabelc::OBBase_HasData;
*DeleteData = *Chemistry::OpenBabelc::OBBase_DeleteData;
*CloneData = *Chemistry::OpenBabelc::OBBase_CloneData;
*DataSize = *Chemistry::OpenBabelc::OBBase_DataSize;
*GetAllData = *Chemistry::OpenBabelc::OBBase_GetAllData;
*GetData = *Chemistry::OpenBabelc::OBBase_GetData;
*BeginData = *Chemistry::OpenBabelc::OBBase_BeginData;
*EndData = *Chemistry::OpenBabelc::OBBase_EndData;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBBase(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBCommentData ##############

package Chemistry::OpenBabel::OBCommentData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBCommentData(@_);
    bless $self, $pkg if defined($self);
}

*SetData = *Chemistry::OpenBabelc::OBCommentData_SetData;
*GetData = *Chemistry::OpenBabelc::OBCommentData_GetData;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBCommentData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBExternalBond ##############

package Chemistry::OpenBabel::OBExternalBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBExternalBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBExternalBond($self);
        delete $OWNER{$self};
    }
}

*GetIdx = *Chemistry::OpenBabelc::OBExternalBond_GetIdx;
*GetAtom = *Chemistry::OpenBabelc::OBExternalBond_GetAtom;
*GetBond = *Chemistry::OpenBabelc::OBExternalBond_GetBond;
*SetIdx = *Chemistry::OpenBabelc::OBExternalBond_SetIdx;
*SetAtom = *Chemistry::OpenBabelc::OBExternalBond_SetAtom;
*SetBond = *Chemistry::OpenBabelc::OBExternalBond_SetBond;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBExternalBondData ##############

package Chemistry::OpenBabel::OBExternalBondData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBExternalBondData(@_);
    bless $self, $pkg if defined($self);
}

*SetData = *Chemistry::OpenBabelc::OBExternalBondData_SetData;
*GetData = *Chemistry::OpenBabelc::OBExternalBondData_GetData;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBExternalBondData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBPairData ##############

package Chemistry::OpenBabel::OBPairData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBPairData(@_);
    bless $self, $pkg if defined($self);
}

*SetValue = *Chemistry::OpenBabelc::OBPairData_SetValue;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBPairData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSetData ##############

package Chemistry::OpenBabel::OBSetData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSetData(@_);
    bless $self, $pkg if defined($self);
}

*AddData = *Chemistry::OpenBabelc::OBSetData_AddData;
*SetData = *Chemistry::OpenBabelc::OBSetData_SetData;
*GetData = *Chemistry::OpenBabelc::OBSetData_GetData;
*GetBegin = *Chemistry::OpenBabelc::OBSetData_GetBegin;
*GetEnd = *Chemistry::OpenBabelc::OBSetData_GetEnd;
*DeleteData = *Chemistry::OpenBabelc::OBSetData_DeleteData;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSetData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBVirtualBond ##############

package Chemistry::OpenBabel::OBVirtualBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBVirtualBond(@_);
    bless $self, $pkg if defined($self);
}

*GetBgn = *Chemistry::OpenBabelc::OBVirtualBond_GetBgn;
*GetEnd = *Chemistry::OpenBabelc::OBVirtualBond_GetEnd;
*GetOrder = *Chemistry::OpenBabelc::OBVirtualBond_GetOrder;
*GetStereo = *Chemistry::OpenBabelc::OBVirtualBond_GetStereo;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBVirtualBond($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRingData ##############

package Chemistry::OpenBabel::OBRingData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRingData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRingData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBRingData_SetData;
*PushBack = *Chemistry::OpenBabelc::OBRingData_PushBack;
*GetData = *Chemistry::OpenBabelc::OBRingData_GetData;
*BeginRings = *Chemistry::OpenBabelc::OBRingData_BeginRings;
*EndRings = *Chemistry::OpenBabelc::OBRingData_EndRings;
*BeginRing = *Chemistry::OpenBabelc::OBRingData_BeginRing;
*NextRing = *Chemistry::OpenBabelc::OBRingData_NextRing;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBUnitCell ##############

package Chemistry::OpenBabel::OBUnitCell;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Undefined = *Chemistry::OpenBabelc::OBUnitCell_Undefined;
*Triclinic = *Chemistry::OpenBabelc::OBUnitCell_Triclinic;
*Monoclinic = *Chemistry::OpenBabelc::OBUnitCell_Monoclinic;
*Orthorhombic = *Chemistry::OpenBabelc::OBUnitCell_Orthorhombic;
*Tetragonal = *Chemistry::OpenBabelc::OBUnitCell_Tetragonal;
*Rhombohedral = *Chemistry::OpenBabelc::OBUnitCell_Rhombohedral;
*Hexagonal = *Chemistry::OpenBabelc::OBUnitCell_Hexagonal;
*Cubic = *Chemistry::OpenBabelc::OBUnitCell_Cubic;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBUnitCell(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBUnitCell($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBUnitCell_SetData;
*SetOffset = *Chemistry::OpenBabelc::OBUnitCell_SetOffset;
*SetSpaceGroup = *Chemistry::OpenBabelc::OBUnitCell_SetSpaceGroup;
*SetLatticeType = *Chemistry::OpenBabelc::OBUnitCell_SetLatticeType;
*FillUnitCell = *Chemistry::OpenBabelc::OBUnitCell_FillUnitCell;
*GetA = *Chemistry::OpenBabelc::OBUnitCell_GetA;
*GetB = *Chemistry::OpenBabelc::OBUnitCell_GetB;
*GetC = *Chemistry::OpenBabelc::OBUnitCell_GetC;
*GetAlpha = *Chemistry::OpenBabelc::OBUnitCell_GetAlpha;
*GetBeta = *Chemistry::OpenBabelc::OBUnitCell_GetBeta;
*GetGamma = *Chemistry::OpenBabelc::OBUnitCell_GetGamma;
*GetOffset = *Chemistry::OpenBabelc::OBUnitCell_GetOffset;
*GetSpaceGroup = *Chemistry::OpenBabelc::OBUnitCell_GetSpaceGroup;
*GetSpaceGroupName = *Chemistry::OpenBabelc::OBUnitCell_GetSpaceGroupName;
*GetLatticeType = *Chemistry::OpenBabelc::OBUnitCell_GetLatticeType;
*GetCellVectors = *Chemistry::OpenBabelc::OBUnitCell_GetCellVectors;
*GetCellMatrix = *Chemistry::OpenBabelc::OBUnitCell_GetCellMatrix;
*GetOrthoMatrix = *Chemistry::OpenBabelc::OBUnitCell_GetOrthoMatrix;
*GetOrientationMatrix = *Chemistry::OpenBabelc::OBUnitCell_GetOrientationMatrix;
*GetFractionalMatrix = *Chemistry::OpenBabelc::OBUnitCell_GetFractionalMatrix;
*FractionalToCartesian = *Chemistry::OpenBabelc::OBUnitCell_FractionalToCartesian;
*CartesianToFractional = *Chemistry::OpenBabelc::OBUnitCell_CartesianToFractional;
*WrapCartesianCoordinate = *Chemistry::OpenBabelc::OBUnitCell_WrapCartesianCoordinate;
*WrapFractionalCoordinate = *Chemistry::OpenBabelc::OBUnitCell_WrapFractionalCoordinate;
*UnwrapCartesianNear = *Chemistry::OpenBabelc::OBUnitCell_UnwrapCartesianNear;
*UnwrapFractionalNear = *Chemistry::OpenBabelc::OBUnitCell_UnwrapFractionalNear;
*MinimumImageCartesian = *Chemistry::OpenBabelc::OBUnitCell_MinimumImageCartesian;
*MinimumImageFractional = *Chemistry::OpenBabelc::OBUnitCell_MinimumImageFractional;
*GetSpaceGroupNumber = *Chemistry::OpenBabelc::OBUnitCell_GetSpaceGroupNumber;
*GetCellVolume = *Chemistry::OpenBabelc::OBUnitCell_GetCellVolume;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBConformerData ##############

package Chemistry::OpenBabel::OBConformerData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBConformerData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBConformerData($self);
        delete $OWNER{$self};
    }
}

*SetDimension = *Chemistry::OpenBabelc::OBConformerData_SetDimension;
*SetEnergies = *Chemistry::OpenBabelc::OBConformerData_SetEnergies;
*SetForces = *Chemistry::OpenBabelc::OBConformerData_SetForces;
*SetVelocities = *Chemistry::OpenBabelc::OBConformerData_SetVelocities;
*SetDisplacements = *Chemistry::OpenBabelc::OBConformerData_SetDisplacements;
*SetData = *Chemistry::OpenBabelc::OBConformerData_SetData;
*GetDimension = *Chemistry::OpenBabelc::OBConformerData_GetDimension;
*GetEnergies = *Chemistry::OpenBabelc::OBConformerData_GetEnergies;
*GetForces = *Chemistry::OpenBabelc::OBConformerData_GetForces;
*GetVelocities = *Chemistry::OpenBabelc::OBConformerData_GetVelocities;
*GetDisplacements = *Chemistry::OpenBabelc::OBConformerData_GetDisplacements;
*GetData = *Chemistry::OpenBabelc::OBConformerData_GetData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSymmetryData ##############

package Chemistry::OpenBabel::OBSymmetryData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSymmetryData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSymmetryData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBSymmetryData_SetData;
*SetPointGroup = *Chemistry::OpenBabelc::OBSymmetryData_SetPointGroup;
*SetSpaceGroup = *Chemistry::OpenBabelc::OBSymmetryData_SetSpaceGroup;
*GetPointGroup = *Chemistry::OpenBabelc::OBSymmetryData_GetPointGroup;
*GetSpaceGroup = *Chemistry::OpenBabelc::OBSymmetryData_GetSpaceGroup;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBTorsion ##############

package Chemistry::OpenBabel::OBTorsion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBTorsion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBTorsion($self);
        delete $OWNER{$self};
    }
}

*Clear = *Chemistry::OpenBabelc::OBTorsion_Clear;
*Empty = *Chemistry::OpenBabelc::OBTorsion_Empty;
*AddTorsion = *Chemistry::OpenBabelc::OBTorsion_AddTorsion;
*SetAngle = *Chemistry::OpenBabelc::OBTorsion_SetAngle;
*SetData = *Chemistry::OpenBabelc::OBTorsion_SetData;
*GetAngle = *Chemistry::OpenBabelc::OBTorsion_GetAngle;
*GetBondIdx = *Chemistry::OpenBabelc::OBTorsion_GetBondIdx;
*GetSize = *Chemistry::OpenBabelc::OBTorsion_GetSize;
*GetBC = *Chemistry::OpenBabelc::OBTorsion_GetBC;
*GetADs = *Chemistry::OpenBabelc::OBTorsion_GetADs;
*IsProtonRotor = *Chemistry::OpenBabelc::OBTorsion_IsProtonRotor;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBTorsionData ##############

package Chemistry::OpenBabel::OBTorsionData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Clear = *Chemistry::OpenBabelc::OBTorsionData_Clear;
*GetData = *Chemistry::OpenBabelc::OBTorsionData_GetData;
*GetSize = *Chemistry::OpenBabelc::OBTorsionData_GetSize;
*SetData = *Chemistry::OpenBabelc::OBTorsionData_SetData;
*FillTorsionArray = *Chemistry::OpenBabelc::OBTorsionData_FillTorsionArray;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBTorsionData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBAngle ##############

package Chemistry::OpenBabel::OBAngle;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBAngle(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBAngle($self);
        delete $OWNER{$self};
    }
}

*__eq__ = *Chemistry::OpenBabelc::OBAngle___eq__;
*Clear = *Chemistry::OpenBabelc::OBAngle_Clear;
*GetAngle = *Chemistry::OpenBabelc::OBAngle_GetAngle;
*SetAngle = *Chemistry::OpenBabelc::OBAngle_SetAngle;
*SetAtoms = *Chemistry::OpenBabelc::OBAngle_SetAtoms;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBAngleData ##############

package Chemistry::OpenBabel::OBAngleData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Clear = *Chemistry::OpenBabelc::OBAngleData_Clear;
*FillAngleArray = *Chemistry::OpenBabelc::OBAngleData_FillAngleArray;
*SetData = *Chemistry::OpenBabelc::OBAngleData_SetData;
*GetSize = *Chemistry::OpenBabelc::OBAngleData_GetSize;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBAngleData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSerialNums ##############

package Chemistry::OpenBabel::OBSerialNums;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSerialNums(@_);
    bless $self, $pkg if defined($self);
}

*GetData = *Chemistry::OpenBabelc::OBSerialNums_GetData;
*SetData = *Chemistry::OpenBabelc::OBSerialNums_SetData;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSerialNums($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBVibrationData ##############

package Chemistry::OpenBabel::OBVibrationData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBVibrationData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBVibrationData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBVibrationData_SetData;
*GetLx = *Chemistry::OpenBabelc::OBVibrationData_GetLx;
*GetFrequencies = *Chemistry::OpenBabelc::OBVibrationData_GetFrequencies;
*GetIntensities = *Chemistry::OpenBabelc::OBVibrationData_GetIntensities;
*GetRamanActivities = *Chemistry::OpenBabelc::OBVibrationData_GetRamanActivities;
*GetNumberOfFrequencies = *Chemistry::OpenBabelc::OBVibrationData_GetNumberOfFrequencies;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBDOSData ##############

package Chemistry::OpenBabel::OBDOSData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBDOSData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBDOSData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBDOSData_SetData;
*GetFermiEnergy = *Chemistry::OpenBabelc::OBDOSData_GetFermiEnergy;
*GetEnergies = *Chemistry::OpenBabelc::OBDOSData_GetEnergies;
*GetDensities = *Chemistry::OpenBabelc::OBDOSData_GetDensities;
*GetIntegration = *Chemistry::OpenBabelc::OBDOSData_GetIntegration;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBOrbital ##############

package Chemistry::OpenBabel::OBOrbital;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*SetData = *Chemistry::OpenBabelc::OBOrbital_SetData;
*GetEnergy = *Chemistry::OpenBabelc::OBOrbital_GetEnergy;
*GetOccupation = *Chemistry::OpenBabelc::OBOrbital_GetOccupation;
*GetSymbol = *Chemistry::OpenBabelc::OBOrbital_GetSymbol;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBOrbital(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBOrbital($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBOrbitalData ##############

package Chemistry::OpenBabel::OBOrbitalData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBOrbitalData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBOrbitalData($self);
        delete $OWNER{$self};
    }
}

*SetAlphaOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_SetAlphaOrbitals;
*SetBetaOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_SetBetaOrbitals;
*SetHOMO = *Chemistry::OpenBabelc::OBOrbitalData_SetHOMO;
*SetOpenShell = *Chemistry::OpenBabelc::OBOrbitalData_SetOpenShell;
*IsOpenShell = *Chemistry::OpenBabelc::OBOrbitalData_IsOpenShell;
*GetAlphaHOMO = *Chemistry::OpenBabelc::OBOrbitalData_GetAlphaHOMO;
*GetBetaHOMO = *Chemistry::OpenBabelc::OBOrbitalData_GetBetaHOMO;
*GetAlphaOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_GetAlphaOrbitals;
*GetBetaOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_GetBetaOrbitals;
*LoadClosedShellOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_LoadClosedShellOrbitals;
*LoadAlphaOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_LoadAlphaOrbitals;
*LoadBetaOrbitals = *Chemistry::OpenBabelc::OBOrbitalData_LoadBetaOrbitals;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBElectronicTransitionData ##############

package Chemistry::OpenBabel::OBElectronicTransitionData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBElectronicTransitionData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBElectronicTransitionData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBElectronicTransitionData_SetData;
*SetEDipole = *Chemistry::OpenBabelc::OBElectronicTransitionData_SetEDipole;
*SetRotatoryStrengthsVelocity = *Chemistry::OpenBabelc::OBElectronicTransitionData_SetRotatoryStrengthsVelocity;
*SetRotatoryStrengthsLength = *Chemistry::OpenBabelc::OBElectronicTransitionData_SetRotatoryStrengthsLength;
*GetWavelengths = *Chemistry::OpenBabelc::OBElectronicTransitionData_GetWavelengths;
*GetForces = *Chemistry::OpenBabelc::OBElectronicTransitionData_GetForces;
*GetEDipole = *Chemistry::OpenBabelc::OBElectronicTransitionData_GetEDipole;
*GetRotatoryStrengthsVelocity = *Chemistry::OpenBabelc::OBElectronicTransitionData_GetRotatoryStrengthsVelocity;
*GetRotatoryStrengthsLength = *Chemistry::OpenBabelc::OBElectronicTransitionData_GetRotatoryStrengthsLength;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotationData ##############

package Chemistry::OpenBabel::OBRotationData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*UNKNOWN = *Chemistry::OpenBabelc::OBRotationData_UNKNOWN;
*ASYMMETRIC = *Chemistry::OpenBabelc::OBRotationData_ASYMMETRIC;
*SYMMETRIC = *Chemistry::OpenBabelc::OBRotationData_SYMMETRIC;
*LINEAR = *Chemistry::OpenBabelc::OBRotationData_LINEAR;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotationData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotationData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBRotationData_SetData;
*GetRotConsts = *Chemistry::OpenBabelc::OBRotationData_GetRotConsts;
*GetSymmetryNumber = *Chemistry::OpenBabelc::OBRotationData_GetSymmetryNumber;
*GetRotorType = *Chemistry::OpenBabelc::OBRotationData_GetRotorType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBVectorData ##############

package Chemistry::OpenBabel::OBVectorData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBVectorData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBVectorData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBVectorData_SetData;
*GetData = *Chemistry::OpenBabelc::OBVectorData_GetData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBMatrixData ##############

package Chemistry::OpenBabel::OBMatrixData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBMatrixData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBMatrixData($self);
        delete $OWNER{$self};
    }
}

*SetData = *Chemistry::OpenBabelc::OBMatrixData_SetData;
*GetData = *Chemistry::OpenBabelc::OBMatrixData_GetData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFreeGridPoint ##############

package Chemistry::OpenBabel::OBFreeGridPoint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFreeGridPoint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFreeGridPoint($self);
        delete $OWNER{$self};
    }
}

*GetX = *Chemistry::OpenBabelc::OBFreeGridPoint_GetX;
*GetY = *Chemistry::OpenBabelc::OBFreeGridPoint_GetY;
*GetZ = *Chemistry::OpenBabelc::OBFreeGridPoint_GetZ;
*GetV = *Chemistry::OpenBabelc::OBFreeGridPoint_GetV;
*SetX = *Chemistry::OpenBabelc::OBFreeGridPoint_SetX;
*SetY = *Chemistry::OpenBabelc::OBFreeGridPoint_SetY;
*SetZ = *Chemistry::OpenBabelc::OBFreeGridPoint_SetZ;
*SetV = *Chemistry::OpenBabelc::OBFreeGridPoint_SetV;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFreeGrid ##############

package Chemistry::OpenBabel::OBFreeGrid;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFreeGrid(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFreeGrid($self);
        delete $OWNER{$self};
    }
}

*NumPoints = *Chemistry::OpenBabelc::OBFreeGrid_NumPoints;
*AddPoint = *Chemistry::OpenBabelc::OBFreeGrid_AddPoint;
*BeginPoints = *Chemistry::OpenBabelc::OBFreeGrid_BeginPoints;
*EndPoints = *Chemistry::OpenBabelc::OBFreeGrid_EndPoints;
*BeginPoint = *Chemistry::OpenBabelc::OBFreeGrid_BeginPoint;
*NextPoint = *Chemistry::OpenBabelc::OBFreeGrid_NextPoint;
*Clear = *Chemistry::OpenBabelc::OBFreeGrid_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBPcharge ##############

package Chemistry::OpenBabel::OBPcharge;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBPcharge(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBPcharge($self);
        delete $OWNER{$self};
    }
}

*NumPartialCharges = *Chemistry::OpenBabelc::OBPcharge_NumPartialCharges;
*AddPartialCharge = *Chemistry::OpenBabelc::OBPcharge_AddPartialCharge;
*GetPartialCharge = *Chemistry::OpenBabelc::OBPcharge_GetPartialCharge;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBGridData ##############

package Chemistry::OpenBabel::OBGridData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBGridData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBGridData($self);
        delete $OWNER{$self};
    }
}

*BOHR = *Chemistry::OpenBabelc::OBGridData_BOHR;
*ANGSTROM = *Chemistry::OpenBabelc::OBGridData_ANGSTROM;
*OTHER = *Chemistry::OpenBabelc::OBGridData_OTHER;
*GetXAxis = *Chemistry::OpenBabelc::OBGridData_GetXAxis;
*GetYAxis = *Chemistry::OpenBabelc::OBGridData_GetYAxis;
*GetZAxis = *Chemistry::OpenBabelc::OBGridData_GetZAxis;
*GetAxes = *Chemistry::OpenBabelc::OBGridData_GetAxes;
*GetNumberOfPoints = *Chemistry::OpenBabelc::OBGridData_GetNumberOfPoints;
*GetNumberOfSteps = *Chemistry::OpenBabelc::OBGridData_GetNumberOfSteps;
*GetValues = *Chemistry::OpenBabelc::OBGridData_GetValues;
*GetValue = *Chemistry::OpenBabelc::OBGridData_GetValue;
*GetUnit = *Chemistry::OpenBabelc::OBGridData_GetUnit;
*GetMinValue = *Chemistry::OpenBabelc::OBGridData_GetMinValue;
*GetMaxValue = *Chemistry::OpenBabelc::OBGridData_GetMaxValue;
*GetOriginVector = *Chemistry::OpenBabelc::OBGridData_GetOriginVector;
*GetMaxVector = *Chemistry::OpenBabelc::OBGridData_GetMaxVector;
*GetUnrestricted = *Chemistry::OpenBabelc::OBGridData_GetUnrestricted;
*GetNumSymmetries = *Chemistry::OpenBabelc::OBGridData_GetNumSymmetries;
*SetNumberOfPoints = *Chemistry::OpenBabelc::OBGridData_SetNumberOfPoints;
*SetLimits = *Chemistry::OpenBabelc::OBGridData_SetLimits;
*SetValue = *Chemistry::OpenBabelc::OBGridData_SetValue;
*SetValues = *Chemistry::OpenBabelc::OBGridData_SetValues;
*SetUnit = *Chemistry::OpenBabelc::OBGridData_SetUnit;
*SetUnrestricted = *Chemistry::OpenBabelc::OBGridData_SetUnrestricted;
*SetNumSymmetries = *Chemistry::OpenBabelc::OBGridData_SetNumSymmetries;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::Dummy ##############

package Chemistry::OpenBabel::Dummy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_Dummy(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_Dummy($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::CharPtrLess ##############

package Chemistry::OpenBabel::CharPtrLess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::Dummy Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Chemistry::OpenBabelc::CharPtrLess___call__;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_CharPtrLess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_CharPtrLess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBPlugin ##############

package Chemistry::OpenBabel::OBPlugin;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBPlugin($self);
        delete $OWNER{$self};
    }
}

*Description = *Chemistry::OpenBabelc::OBPlugin_Description;
*TypeID = *Chemistry::OpenBabelc::OBPlugin_TypeID;
*Display = *Chemistry::OpenBabelc::OBPlugin_Display;
*MakeInstance = *Chemistry::OpenBabelc::OBPlugin_MakeInstance;
*Init = *Chemistry::OpenBabelc::OBPlugin_Init;
*GetPlugin = *Chemistry::OpenBabelc::OBPlugin_GetPlugin;
*GetID = *Chemistry::OpenBabelc::OBPlugin_GetID;
*ListAsVector = *Chemistry::OpenBabelc::OBPlugin_ListAsVector;
*List = *Chemistry::OpenBabelc::OBPlugin_List;
*ListAsString = *Chemistry::OpenBabelc::OBPlugin_ListAsString;
*FirstLine = *Chemistry::OpenBabelc::OBPlugin_FirstLine;
*Begin = *Chemistry::OpenBabelc::OBPlugin_Begin;
*End = *Chemistry::OpenBabelc::OBPlugin_End;
*GetMap = *Chemistry::OpenBabelc::OBPlugin_GetMap;
*LoadAllPlugins = *Chemistry::OpenBabelc::OBPlugin_LoadAllPlugins;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::stringbuf ##############

package Chemistry::OpenBabel::stringbuf;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_stringbuf(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_stringbuf($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBError ##############

package Chemistry::OpenBabel::OBError;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBError(@_);
    bless $self, $pkg if defined($self);
}

*message = *Chemistry::OpenBabelc::OBError_message;
*GetMethod = *Chemistry::OpenBabelc::OBError_GetMethod;
*GetError = *Chemistry::OpenBabelc::OBError_GetError;
*GetExplanation = *Chemistry::OpenBabelc::OBError_GetExplanation;
*GetPossibleCause = *Chemistry::OpenBabelc::OBError_GetPossibleCause;
*GetSuggestedRemedy = *Chemistry::OpenBabelc::OBError_GetSuggestedRemedy;
*GetLevel = *Chemistry::OpenBabelc::OBError_GetLevel;
*__eq__ = *Chemistry::OpenBabelc::OBError___eq__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBMessageHandler ##############

package Chemistry::OpenBabel::OBMessageHandler;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBMessageHandler(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBMessageHandler($self);
        delete $OWNER{$self};
    }
}

*ThrowError = *Chemistry::OpenBabelc::OBMessageHandler_ThrowError;
*GetMessagesOfLevel = *Chemistry::OpenBabelc::OBMessageHandler_GetMessagesOfLevel;
*StartLogging = *Chemistry::OpenBabelc::OBMessageHandler_StartLogging;
*StopLogging = *Chemistry::OpenBabelc::OBMessageHandler_StopLogging;
*SetMaxLogEntries = *Chemistry::OpenBabelc::OBMessageHandler_SetMaxLogEntries;
*GetMaxLogEntries = *Chemistry::OpenBabelc::OBMessageHandler_GetMaxLogEntries;
*ClearLog = *Chemistry::OpenBabelc::OBMessageHandler_ClearLog;
*SetOutputLevel = *Chemistry::OpenBabelc::OBMessageHandler_SetOutputLevel;
*GetOutputLevel = *Chemistry::OpenBabelc::OBMessageHandler_GetOutputLevel;
*SetOutputStream = *Chemistry::OpenBabelc::OBMessageHandler_SetOutputStream;
*GetOutputStream = *Chemistry::OpenBabelc::OBMessageHandler_GetOutputStream;
*StartErrorWrap = *Chemistry::OpenBabelc::OBMessageHandler_StartErrorWrap;
*StopErrorWrap = *Chemistry::OpenBabelc::OBMessageHandler_StopErrorWrap;
*GetErrorMessageCount = *Chemistry::OpenBabelc::OBMessageHandler_GetErrorMessageCount;
*GetWarningMessageCount = *Chemistry::OpenBabelc::OBMessageHandler_GetWarningMessageCount;
*GetInfoMessageCount = *Chemistry::OpenBabelc::OBMessageHandler_GetInfoMessageCount;
*GetAuditMessageCount = *Chemistry::OpenBabelc::OBMessageHandler_GetAuditMessageCount;
*GetDebugMessageCount = *Chemistry::OpenBabelc::OBMessageHandler_GetDebugMessageCount;
*GetMessageSummary = *Chemistry::OpenBabelc::OBMessageHandler_GetMessageSummary;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::obLogBuf ##############

package Chemistry::OpenBabel::obLogBuf;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::stringbuf Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_obLogBuf($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_obLogBuf(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFormat ##############

package Chemistry::OpenBabel::OBFormat;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBPlugin Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Default = *Chemistry::OpenBabelc::OBFormat_Default;
*FindType = *Chemistry::OpenBabelc::OBFormat_FindType;
*ReadMolecule = *Chemistry::OpenBabelc::OBFormat_ReadMolecule;
*ReadChemObject = *Chemistry::OpenBabelc::OBFormat_ReadChemObject;
*WriteMolecule = *Chemistry::OpenBabelc::OBFormat_WriteMolecule;
*WriteChemObject = *Chemistry::OpenBabelc::OBFormat_WriteChemObject;
*TargetClassDescription = *Chemistry::OpenBabelc::OBFormat_TargetClassDescription;
*GetType = *Chemistry::OpenBabelc::OBFormat_GetType;
*SpecificationURL = *Chemistry::OpenBabelc::OBFormat_SpecificationURL;
*GetMIMEType = *Chemistry::OpenBabelc::OBFormat_GetMIMEType;
*Flags = *Chemistry::OpenBabelc::OBFormat_Flags;
*SkipObjects = *Chemistry::OpenBabelc::OBFormat_SkipObjects;
*MakeNewInstance = *Chemistry::OpenBabelc::OBFormat_MakeNewInstance;
*RegisterFormat = *Chemistry::OpenBabelc::OBFormat_RegisterFormat;
*Display = *Chemistry::OpenBabelc::OBFormat_Display;
*FormatFromMIME = *Chemistry::OpenBabelc::OBFormat_FormatFromMIME;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFormat($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBConversion ##############

package Chemistry::OpenBabel::OBConversion;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBConversion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBConversion($self);
        delete $OWNER{$self};
    }
}

*RegisterFormat = *Chemistry::OpenBabelc::OBConversion_RegisterFormat;
*FindFormat = *Chemistry::OpenBabelc::OBConversion_FindFormat;
*FormatFromExt = *Chemistry::OpenBabelc::OBConversion_FormatFromExt;
*FormatFromMIME = *Chemistry::OpenBabelc::OBConversion_FormatFromMIME;
*Description = *Chemistry::OpenBabelc::OBConversion_Description;
*GetInStream = *Chemistry::OpenBabelc::OBConversion_GetInStream;
*GetOutStream = *Chemistry::OpenBabelc::OBConversion_GetOutStream;
*SetInStream = *Chemistry::OpenBabelc::OBConversion_SetInStream;
*SetOutStream = *Chemistry::OpenBabelc::OBConversion_SetOutStream;
*SetInAndOutFormats = *Chemistry::OpenBabelc::OBConversion_SetInAndOutFormats;
*SetInFormat = *Chemistry::OpenBabelc::OBConversion_SetInFormat;
*SetOutFormat = *Chemistry::OpenBabelc::OBConversion_SetOutFormat;
*GetInFormat = *Chemistry::OpenBabelc::OBConversion_GetInFormat;
*GetOutFormat = *Chemistry::OpenBabelc::OBConversion_GetOutFormat;
*GetInGzipped = *Chemistry::OpenBabelc::OBConversion_GetInGzipped;
*GetOutGzipped = *Chemistry::OpenBabelc::OBConversion_GetOutGzipped;
*GetInFilename = *Chemistry::OpenBabelc::OBConversion_GetInFilename;
*GetOutFilename = *Chemistry::OpenBabelc::OBConversion_GetOutFilename;
*GetInPos = *Chemistry::OpenBabelc::OBConversion_GetInPos;
*GetInLen = *Chemistry::OpenBabelc::OBConversion_GetInLen;
*GetTitle = *Chemistry::OpenBabelc::OBConversion_GetTitle;
*GetAuxConv = *Chemistry::OpenBabelc::OBConversion_GetAuxConv;
*SetAuxConv = *Chemistry::OpenBabelc::OBConversion_SetAuxConv;
*INOPTIONS = *Chemistry::OpenBabelc::OBConversion_INOPTIONS;
*OUTOPTIONS = *Chemistry::OpenBabelc::OBConversion_OUTOPTIONS;
*GENOPTIONS = *Chemistry::OpenBabelc::OBConversion_GENOPTIONS;
*ALL = *Chemistry::OpenBabelc::OBConversion_ALL;
*IsOption = *Chemistry::OpenBabelc::OBConversion_IsOption;
*GetOptions = *Chemistry::OpenBabelc::OBConversion_GetOptions;
*AddOption = *Chemistry::OpenBabelc::OBConversion_AddOption;
*RemoveOption = *Chemistry::OpenBabelc::OBConversion_RemoveOption;
*SetOptions = *Chemistry::OpenBabelc::OBConversion_SetOptions;
*RegisterOptionParam = *Chemistry::OpenBabelc::OBConversion_RegisterOptionParam;
*GetOptionParams = *Chemistry::OpenBabelc::OBConversion_GetOptionParams;
*CopyOptions = *Chemistry::OpenBabelc::OBConversion_CopyOptions;
*GetSupportedInputFormat = *Chemistry::OpenBabelc::OBConversion_GetSupportedInputFormat;
*GetSupportedOutputFormat = *Chemistry::OpenBabelc::OBConversion_GetSupportedOutputFormat;
*Convert = *Chemistry::OpenBabelc::OBConversion_Convert;
*FullConvert = *Chemistry::OpenBabelc::OBConversion_FullConvert;
*AddChemObject = *Chemistry::OpenBabelc::OBConversion_AddChemObject;
*GetChemObject = *Chemistry::OpenBabelc::OBConversion_GetChemObject;
*IsLast = *Chemistry::OpenBabelc::OBConversion_IsLast;
*IsFirstInput = *Chemistry::OpenBabelc::OBConversion_IsFirstInput;
*SetFirstInput = *Chemistry::OpenBabelc::OBConversion_SetFirstInput;
*GetOutputIndex = *Chemistry::OpenBabelc::OBConversion_GetOutputIndex;
*SetOutputIndex = *Chemistry::OpenBabelc::OBConversion_SetOutputIndex;
*SetMoreFilesToCome = *Chemistry::OpenBabelc::OBConversion_SetMoreFilesToCome;
*SetOneObjectOnly = *Chemistry::OpenBabelc::OBConversion_SetOneObjectOnly;
*SetLast = *Chemistry::OpenBabelc::OBConversion_SetLast;
*IsLastFile = *Chemistry::OpenBabelc::OBConversion_IsLastFile;
*GetCount = *Chemistry::OpenBabelc::OBConversion_GetCount;
*GetDefaultFormat = *Chemistry::OpenBabelc::OBConversion_GetDefaultFormat;
*Write = *Chemistry::OpenBabelc::OBConversion_Write;
*WriteString = *Chemistry::OpenBabelc::OBConversion_WriteString;
*WriteFile = *Chemistry::OpenBabelc::OBConversion_WriteFile;
*CloseOutFile = *Chemistry::OpenBabelc::OBConversion_CloseOutFile;
*Read = *Chemistry::OpenBabelc::OBConversion_Read;
*ReadString = *Chemistry::OpenBabelc::OBConversion_ReadString;
*ReadFile = *Chemistry::OpenBabelc::OBConversion_ReadFile;
*OpenInAndOutFiles = *Chemistry::OpenBabelc::OBConversion_OpenInAndOutFiles;
*ReportNumberConverted = *Chemistry::OpenBabelc::OBConversion_ReportNumberConverted;
*NumInputObjects = *Chemistry::OpenBabelc::OBConversion_NumInputObjects;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBResidue ##############

package Chemistry::OpenBabel::OBResidue;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBResidue(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBResidue($self);
        delete $OWNER{$self};
    }
}

*AddAtom = *Chemistry::OpenBabelc::OBResidue_AddAtom;
*InsertAtom = *Chemistry::OpenBabelc::OBResidue_InsertAtom;
*RemoveAtom = *Chemistry::OpenBabelc::OBResidue_RemoveAtom;
*SetName = *Chemistry::OpenBabelc::OBResidue_SetName;
*SetNum = *Chemistry::OpenBabelc::OBResidue_SetNum;
*SetChain = *Chemistry::OpenBabelc::OBResidue_SetChain;
*SetChainNum = *Chemistry::OpenBabelc::OBResidue_SetChainNum;
*SetIdx = *Chemistry::OpenBabelc::OBResidue_SetIdx;
*SetInsertionCode = *Chemistry::OpenBabelc::OBResidue_SetInsertionCode;
*SetAtomID = *Chemistry::OpenBabelc::OBResidue_SetAtomID;
*SetHetAtom = *Chemistry::OpenBabelc::OBResidue_SetHetAtom;
*SetSerialNum = *Chemistry::OpenBabelc::OBResidue_SetSerialNum;
*GetName = *Chemistry::OpenBabelc::OBResidue_GetName;
*GetNum = *Chemistry::OpenBabelc::OBResidue_GetNum;
*GetNumString = *Chemistry::OpenBabelc::OBResidue_GetNumString;
*GetNumAtoms = *Chemistry::OpenBabelc::OBResidue_GetNumAtoms;
*GetChain = *Chemistry::OpenBabelc::OBResidue_GetChain;
*GetChainNum = *Chemistry::OpenBabelc::OBResidue_GetChainNum;
*GetIdx = *Chemistry::OpenBabelc::OBResidue_GetIdx;
*GetResKey = *Chemistry::OpenBabelc::OBResidue_GetResKey;
*GetAtoms = *Chemistry::OpenBabelc::OBResidue_GetAtoms;
*GetBonds = *Chemistry::OpenBabelc::OBResidue_GetBonds;
*GetAtomID = *Chemistry::OpenBabelc::OBResidue_GetAtomID;
*GetSerialNum = *Chemistry::OpenBabelc::OBResidue_GetSerialNum;
*GetInsertionCode = *Chemistry::OpenBabelc::OBResidue_GetInsertionCode;
*GetAminoAcidProperty = *Chemistry::OpenBabelc::OBResidue_GetAminoAcidProperty;
*GetAtomProperty = *Chemistry::OpenBabelc::OBResidue_GetAtomProperty;
*GetResidueProperty = *Chemistry::OpenBabelc::OBResidue_GetResidueProperty;
*IsHetAtom = *Chemistry::OpenBabelc::OBResidue_IsHetAtom;
*IsResidueType = *Chemistry::OpenBabelc::OBResidue_IsResidueType;
*BeginAtoms = *Chemistry::OpenBabelc::OBResidue_BeginAtoms;
*EndAtoms = *Chemistry::OpenBabelc::OBResidue_EndAtoms;
*BeginAtom = *Chemistry::OpenBabelc::OBResidue_BeginAtom;
*NextAtom = *Chemistry::OpenBabelc::OBResidue_NextAtom;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBInternalCoord ##############

package Chemistry::OpenBabel::OBInternalCoord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig__a_get = *Chemistry::OpenBabelc::OBInternalCoord__a_get;
*swig__a_set = *Chemistry::OpenBabelc::OBInternalCoord__a_set;
*swig__b_get = *Chemistry::OpenBabelc::OBInternalCoord__b_get;
*swig__b_set = *Chemistry::OpenBabelc::OBInternalCoord__b_set;
*swig__c_get = *Chemistry::OpenBabelc::OBInternalCoord__c_get;
*swig__c_set = *Chemistry::OpenBabelc::OBInternalCoord__c_set;
*swig__dst_get = *Chemistry::OpenBabelc::OBInternalCoord__dst_get;
*swig__dst_set = *Chemistry::OpenBabelc::OBInternalCoord__dst_set;
*swig__ang_get = *Chemistry::OpenBabelc::OBInternalCoord__ang_get;
*swig__ang_set = *Chemistry::OpenBabelc::OBInternalCoord__ang_set;
*swig__tor_get = *Chemistry::OpenBabelc::OBInternalCoord__tor_get;
*swig__tor_set = *Chemistry::OpenBabelc::OBInternalCoord__tor_set;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBInternalCoord(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBInternalCoord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBAtom ##############

package Chemistry::OpenBabel::OBAtom;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_Visit_get = *Chemistry::OpenBabelc::OBAtom_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::OBAtom_Visit_set;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBAtom(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBAtom($self);
        delete $OWNER{$self};
    }
}

*__eq__ = *Chemistry::OpenBabelc::OBAtom___eq__;
*Duplicate = *Chemistry::OpenBabelc::OBAtom_Duplicate;
*SetIdx = *Chemistry::OpenBabelc::OBAtom_SetIdx;
*SetId = *Chemistry::OpenBabelc::OBAtom_SetId;
*SetHyb = *Chemistry::OpenBabelc::OBAtom_SetHyb;
*SetAtomicNum = *Chemistry::OpenBabelc::OBAtom_SetAtomicNum;
*SetIsotope = *Chemistry::OpenBabelc::OBAtom_SetIsotope;
*SetImplicitHCount = *Chemistry::OpenBabelc::OBAtom_SetImplicitHCount;
*SetFormalCharge = *Chemistry::OpenBabelc::OBAtom_SetFormalCharge;
*SetSpinMultiplicity = *Chemistry::OpenBabelc::OBAtom_SetSpinMultiplicity;
*SetType = *Chemistry::OpenBabelc::OBAtom_SetType;
*SetPartialCharge = *Chemistry::OpenBabelc::OBAtom_SetPartialCharge;
*SetCoordPtr = *Chemistry::OpenBabelc::OBAtom_SetCoordPtr;
*SetVector = *Chemistry::OpenBabelc::OBAtom_SetVector;
*SetResidue = *Chemistry::OpenBabelc::OBAtom_SetResidue;
*SetParent = *Chemistry::OpenBabelc::OBAtom_SetParent;
*SetAromatic = *Chemistry::OpenBabelc::OBAtom_SetAromatic;
*SetInRing = *Chemistry::OpenBabelc::OBAtom_SetInRing;
*ClearCoordPtr = *Chemistry::OpenBabelc::OBAtom_ClearCoordPtr;
*GetFormalCharge = *Chemistry::OpenBabelc::OBAtom_GetFormalCharge;
*GetAtomicNum = *Chemistry::OpenBabelc::OBAtom_GetAtomicNum;
*GetIsotope = *Chemistry::OpenBabelc::OBAtom_GetIsotope;
*GetSpinMultiplicity = *Chemistry::OpenBabelc::OBAtom_GetSpinMultiplicity;
*GetAtomicMass = *Chemistry::OpenBabelc::OBAtom_GetAtomicMass;
*GetExactMass = *Chemistry::OpenBabelc::OBAtom_GetExactMass;
*GetIdx = *Chemistry::OpenBabelc::OBAtom_GetIdx;
*GetIndex = *Chemistry::OpenBabelc::OBAtom_GetIndex;
*GetId = *Chemistry::OpenBabelc::OBAtom_GetId;
*GetCoordinateIdx = *Chemistry::OpenBabelc::OBAtom_GetCoordinateIdx;
*GetExplicitDegree = *Chemistry::OpenBabelc::OBAtom_GetExplicitDegree;
*GetTotalDegree = *Chemistry::OpenBabelc::OBAtom_GetTotalDegree;
*GetExplicitValence = *Chemistry::OpenBabelc::OBAtom_GetExplicitValence;
*GetTotalValence = *Chemistry::OpenBabelc::OBAtom_GetTotalValence;
*GetHyb = *Chemistry::OpenBabelc::OBAtom_GetHyb;
*GetImplicitHCount = *Chemistry::OpenBabelc::OBAtom_GetImplicitHCount;
*GetHvyDegree = *Chemistry::OpenBabelc::OBAtom_GetHvyDegree;
*GetHeteroDegree = *Chemistry::OpenBabelc::OBAtom_GetHeteroDegree;
*GetType = *Chemistry::OpenBabelc::OBAtom_GetType;
*GetX = *Chemistry::OpenBabelc::OBAtom_GetX;
*GetY = *Chemistry::OpenBabelc::OBAtom_GetY;
*GetZ = *Chemistry::OpenBabelc::OBAtom_GetZ;
*x = *Chemistry::OpenBabelc::OBAtom_x;
*y = *Chemistry::OpenBabelc::OBAtom_y;
*z = *Chemistry::OpenBabelc::OBAtom_z;
*GetCoordinate = *Chemistry::OpenBabelc::OBAtom_GetCoordinate;
*GetVector = *Chemistry::OpenBabelc::OBAtom_GetVector;
*GetPartialCharge = *Chemistry::OpenBabelc::OBAtom_GetPartialCharge;
*GetResidue = *Chemistry::OpenBabelc::OBAtom_GetResidue;
*GetParent = *Chemistry::OpenBabelc::OBAtom_GetParent;
*GetNewBondVector = *Chemistry::OpenBabelc::OBAtom_GetNewBondVector;
*GetBond = *Chemistry::OpenBabelc::OBAtom_GetBond;
*BeginBonds = *Chemistry::OpenBabelc::OBAtom_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::OBAtom_EndBonds;
*BeginBond = *Chemistry::OpenBabelc::OBAtom_BeginBond;
*NextBond = *Chemistry::OpenBabelc::OBAtom_NextBond;
*BeginNbrAtom = *Chemistry::OpenBabelc::OBAtom_BeginNbrAtom;
*NextNbrAtom = *Chemistry::OpenBabelc::OBAtom_NextNbrAtom;
*GetDistance = *Chemistry::OpenBabelc::OBAtom_GetDistance;
*GetAngle = *Chemistry::OpenBabelc::OBAtom_GetAngle;
*NewResidue = *Chemistry::OpenBabelc::OBAtom_NewResidue;
*AddResidue = *Chemistry::OpenBabelc::OBAtom_AddResidue;
*DeleteResidue = *Chemistry::OpenBabelc::OBAtom_DeleteResidue;
*AddBond = *Chemistry::OpenBabelc::OBAtom_AddBond;
*InsertBond = *Chemistry::OpenBabelc::OBAtom_InsertBond;
*DeleteBond = *Chemistry::OpenBabelc::OBAtom_DeleteBond;
*ClearBond = *Chemistry::OpenBabelc::OBAtom_ClearBond;
*HtoMethyl = *Chemistry::OpenBabelc::OBAtom_HtoMethyl;
*SetHybAndGeom = *Chemistry::OpenBabelc::OBAtom_SetHybAndGeom;
*CountFreeOxygens = *Chemistry::OpenBabelc::OBAtom_CountFreeOxygens;
*CountFreeSulfurs = *Chemistry::OpenBabelc::OBAtom_CountFreeSulfurs;
*ExplicitHydrogenCount = *Chemistry::OpenBabelc::OBAtom_ExplicitHydrogenCount;
*MemberOfRingCount = *Chemistry::OpenBabelc::OBAtom_MemberOfRingCount;
*MemberOfRingSize = *Chemistry::OpenBabelc::OBAtom_MemberOfRingSize;
*CountRingBonds = *Chemistry::OpenBabelc::OBAtom_CountRingBonds;
*SmallestBondAngle = *Chemistry::OpenBabelc::OBAtom_SmallestBondAngle;
*AverageBondAngle = *Chemistry::OpenBabelc::OBAtom_AverageBondAngle;
*LewisAcidBaseCounts = *Chemistry::OpenBabelc::OBAtom_LewisAcidBaseCounts;
*HasResidue = *Chemistry::OpenBabelc::OBAtom_HasResidue;
*IsHetAtom = *Chemistry::OpenBabelc::OBAtom_IsHetAtom;
*IsElement = *Chemistry::OpenBabelc::OBAtom_IsElement;
*IsAromatic = *Chemistry::OpenBabelc::OBAtom_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::OBAtom_IsInRing;
*IsInRingSize = *Chemistry::OpenBabelc::OBAtom_IsInRingSize;
*IsHeteroatom = *Chemistry::OpenBabelc::OBAtom_IsHeteroatom;
*IsConnected = *Chemistry::OpenBabelc::OBAtom_IsConnected;
*IsOneThree = *Chemistry::OpenBabelc::OBAtom_IsOneThree;
*IsOneFour = *Chemistry::OpenBabelc::OBAtom_IsOneFour;
*IsCarboxylOxygen = *Chemistry::OpenBabelc::OBAtom_IsCarboxylOxygen;
*IsPhosphateOxygen = *Chemistry::OpenBabelc::OBAtom_IsPhosphateOxygen;
*IsSulfateOxygen = *Chemistry::OpenBabelc::OBAtom_IsSulfateOxygen;
*IsNitroOxygen = *Chemistry::OpenBabelc::OBAtom_IsNitroOxygen;
*IsAmideNitrogen = *Chemistry::OpenBabelc::OBAtom_IsAmideNitrogen;
*IsPolarHydrogen = *Chemistry::OpenBabelc::OBAtom_IsPolarHydrogen;
*IsNonPolarHydrogen = *Chemistry::OpenBabelc::OBAtom_IsNonPolarHydrogen;
*IsAromaticNOxide = *Chemistry::OpenBabelc::OBAtom_IsAromaticNOxide;
*IsChiral = *Chemistry::OpenBabelc::OBAtom_IsChiral;
*IsPeriodic = *Chemistry::OpenBabelc::OBAtom_IsPeriodic;
*IsAxial = *Chemistry::OpenBabelc::OBAtom_IsAxial;
*IsHbondAcceptor = *Chemistry::OpenBabelc::OBAtom_IsHbondAcceptor;
*IsHbondAcceptorSimple = *Chemistry::OpenBabelc::OBAtom_IsHbondAcceptorSimple;
*IsHbondDonor = *Chemistry::OpenBabelc::OBAtom_IsHbondDonor;
*IsHbondDonorH = *Chemistry::OpenBabelc::OBAtom_IsHbondDonorH;
*IsMetal = *Chemistry::OpenBabelc::OBAtom_IsMetal;
*HasAlphaBetaUnsat = *Chemistry::OpenBabelc::OBAtom_HasAlphaBetaUnsat;
*HasBondOfOrder = *Chemistry::OpenBabelc::OBAtom_HasBondOfOrder;
*CountBondsOfOrder = *Chemistry::OpenBabelc::OBAtom_CountBondsOfOrder;
*HighestBondOrder = *Chemistry::OpenBabelc::OBAtom_HighestBondOrder;
*HasNonSingleBond = *Chemistry::OpenBabelc::OBAtom_HasNonSingleBond;
*HasSingleBond = *Chemistry::OpenBabelc::OBAtom_HasSingleBond;
*HasDoubleBond = *Chemistry::OpenBabelc::OBAtom_HasDoubleBond;
*HasAromaticBond = *Chemistry::OpenBabelc::OBAtom_HasAromaticBond;
*MatchesSMARTS = *Chemistry::OpenBabelc::OBAtom_MatchesSMARTS;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBBond ##############

package Chemistry::OpenBabel::OBBond;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Aromatic = *Chemistry::OpenBabelc::OBBond_Aromatic;
*Ring = *Chemistry::OpenBabelc::OBBond_Ring;
*Closure = *Chemistry::OpenBabelc::OBBond_Closure;
*Wedge = *Chemistry::OpenBabelc::OBBond_Wedge;
*Hash = *Chemistry::OpenBabelc::OBBond_Hash;
*WedgeOrHash = *Chemistry::OpenBabelc::OBBond_WedgeOrHash;
*CisOrTrans = *Chemistry::OpenBabelc::OBBond_CisOrTrans;
*swig_Visit_get = *Chemistry::OpenBabelc::OBBond_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::OBBond_Visit_set;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBBond(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBBond($self);
        delete $OWNER{$self};
    }
}

*SetIdx = *Chemistry::OpenBabelc::OBBond_SetIdx;
*SetId = *Chemistry::OpenBabelc::OBBond_SetId;
*SetBondOrder = *Chemistry::OpenBabelc::OBBond_SetBondOrder;
*SetBegin = *Chemistry::OpenBabelc::OBBond_SetBegin;
*SetEnd = *Chemistry::OpenBabelc::OBBond_SetEnd;
*SetParent = *Chemistry::OpenBabelc::OBBond_SetParent;
*SetLength = *Chemistry::OpenBabelc::OBBond_SetLength;
*Set = *Chemistry::OpenBabelc::OBBond_Set;
*SetAromatic = *Chemistry::OpenBabelc::OBBond_SetAromatic;
*SetWedge = *Chemistry::OpenBabelc::OBBond_SetWedge;
*SetHash = *Chemistry::OpenBabelc::OBBond_SetHash;
*SetWedgeOrHash = *Chemistry::OpenBabelc::OBBond_SetWedgeOrHash;
*SetInRing = *Chemistry::OpenBabelc::OBBond_SetInRing;
*SetClosure = *Chemistry::OpenBabelc::OBBond_SetClosure;
*GetIdx = *Chemistry::OpenBabelc::OBBond_GetIdx;
*GetId = *Chemistry::OpenBabelc::OBBond_GetId;
*GetBondOrder = *Chemistry::OpenBabelc::OBBond_GetBondOrder;
*GetFlags = *Chemistry::OpenBabelc::OBBond_GetFlags;
*GetBeginAtomIdx = *Chemistry::OpenBabelc::OBBond_GetBeginAtomIdx;
*GetEndAtomIdx = *Chemistry::OpenBabelc::OBBond_GetEndAtomIdx;
*GetBeginAtom = *Chemistry::OpenBabelc::OBBond_GetBeginAtom;
*GetEndAtom = *Chemistry::OpenBabelc::OBBond_GetEndAtom;
*GetNbrAtom = *Chemistry::OpenBabelc::OBBond_GetNbrAtom;
*GetParent = *Chemistry::OpenBabelc::OBBond_GetParent;
*GetEquibLength = *Chemistry::OpenBabelc::OBBond_GetEquibLength;
*GetLength = *Chemistry::OpenBabelc::OBBond_GetLength;
*GetNbrAtomIdx = *Chemistry::OpenBabelc::OBBond_GetNbrAtomIdx;
*FindSmallestRing = *Chemistry::OpenBabelc::OBBond_FindSmallestRing;
*IsAromatic = *Chemistry::OpenBabelc::OBBond_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::OBBond_IsInRing;
*IsRotor = *Chemistry::OpenBabelc::OBBond_IsRotor;
*IsPeriodic = *Chemistry::OpenBabelc::OBBond_IsPeriodic;
*IsAmide = *Chemistry::OpenBabelc::OBBond_IsAmide;
*IsPrimaryAmide = *Chemistry::OpenBabelc::OBBond_IsPrimaryAmide;
*IsSecondaryAmide = *Chemistry::OpenBabelc::OBBond_IsSecondaryAmide;
*IsTertiaryAmide = *Chemistry::OpenBabelc::OBBond_IsTertiaryAmide;
*IsEster = *Chemistry::OpenBabelc::OBBond_IsEster;
*IsCarbonyl = *Chemistry::OpenBabelc::OBBond_IsCarbonyl;
*IsClosure = *Chemistry::OpenBabelc::OBBond_IsClosure;
*IsWedge = *Chemistry::OpenBabelc::OBBond_IsWedge;
*IsHash = *Chemistry::OpenBabelc::OBBond_IsHash;
*IsWedgeOrHash = *Chemistry::OpenBabelc::OBBond_IsWedgeOrHash;
*IsCisOrTrans = *Chemistry::OpenBabelc::OBBond_IsCisOrTrans;
*IsDoubleBondGeometry = *Chemistry::OpenBabelc::OBBond_IsDoubleBondGeometry;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBMol ##############

package Chemistry::OpenBabel::OBMol;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBMol(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBMol($self);
        delete $OWNER{$self};
    }
}

*add = *Chemistry::OpenBabelc::OBMol_add;
*ReserveAtoms = *Chemistry::OpenBabelc::OBMol_ReserveAtoms;
*DestroyAtom = *Chemistry::OpenBabelc::OBMol_DestroyAtom;
*DestroyBond = *Chemistry::OpenBabelc::OBMol_DestroyBond;
*DestroyResidue = *Chemistry::OpenBabelc::OBMol_DestroyResidue;
*AddAtom = *Chemistry::OpenBabelc::OBMol_AddAtom;
*InsertAtom = *Chemistry::OpenBabelc::OBMol_InsertAtom;
*AddBond = *Chemistry::OpenBabelc::OBMol_AddBond;
*AddResidue = *Chemistry::OpenBabelc::OBMol_AddResidue;
*NewAtom = *Chemistry::OpenBabelc::OBMol_NewAtom;
*NewBond = *Chemistry::OpenBabelc::OBMol_NewBond;
*NewResidue = *Chemistry::OpenBabelc::OBMol_NewResidue;
*DeleteAtom = *Chemistry::OpenBabelc::OBMol_DeleteAtom;
*DeleteBond = *Chemistry::OpenBabelc::OBMol_DeleteBond;
*DeleteResidue = *Chemistry::OpenBabelc::OBMol_DeleteResidue;
*BeginModify = *Chemistry::OpenBabelc::OBMol_BeginModify;
*EndModify = *Chemistry::OpenBabelc::OBMol_EndModify;
*GetMod = *Chemistry::OpenBabelc::OBMol_GetMod;
*IncrementMod = *Chemistry::OpenBabelc::OBMol_IncrementMod;
*DecrementMod = *Chemistry::OpenBabelc::OBMol_DecrementMod;
*GetFlags = *Chemistry::OpenBabelc::OBMol_GetFlags;
*GetTitle = *Chemistry::OpenBabelc::OBMol_GetTitle;
*NumAtoms = *Chemistry::OpenBabelc::OBMol_NumAtoms;
*NumBonds = *Chemistry::OpenBabelc::OBMol_NumBonds;
*NumHvyAtoms = *Chemistry::OpenBabelc::OBMol_NumHvyAtoms;
*NumResidues = *Chemistry::OpenBabelc::OBMol_NumResidues;
*NumRotors = *Chemistry::OpenBabelc::OBMol_NumRotors;
*GetAtom = *Chemistry::OpenBabelc::OBMol_GetAtom;
*GetAtomById = *Chemistry::OpenBabelc::OBMol_GetAtomById;
*GetFirstAtom = *Chemistry::OpenBabelc::OBMol_GetFirstAtom;
*GetBondById = *Chemistry::OpenBabelc::OBMol_GetBondById;
*GetBond = *Chemistry::OpenBabelc::OBMol_GetBond;
*GetResidue = *Chemistry::OpenBabelc::OBMol_GetResidue;
*GetInternalCoord = *Chemistry::OpenBabelc::OBMol_GetInternalCoord;
*GetTorsion = *Chemistry::OpenBabelc::OBMol_GetTorsion;
*GetAngle = *Chemistry::OpenBabelc::OBMol_GetAngle;
*AreInSameRing = *Chemistry::OpenBabelc::OBMol_AreInSameRing;
*GetFormula = *Chemistry::OpenBabelc::OBMol_GetFormula;
*GetSpacedFormula = *Chemistry::OpenBabelc::OBMol_GetSpacedFormula;
*GetMolWt = *Chemistry::OpenBabelc::OBMol_GetMolWt;
*GetExactMass = *Chemistry::OpenBabelc::OBMol_GetExactMass;
*GetTotalCharge = *Chemistry::OpenBabelc::OBMol_GetTotalCharge;
*GetTotalSpinMultiplicity = *Chemistry::OpenBabelc::OBMol_GetTotalSpinMultiplicity;
*GetDimension = *Chemistry::OpenBabelc::OBMol_GetDimension;
*GetCoordinates = *Chemistry::OpenBabelc::OBMol_GetCoordinates;
*GetSSSR = *Chemistry::OpenBabelc::OBMol_GetSSSR;
*GetLSSR = *Chemistry::OpenBabelc::OBMol_GetLSSR;
*AutomaticFormalCharge = *Chemistry::OpenBabelc::OBMol_AutomaticFormalCharge;
*AutomaticPartialCharge = *Chemistry::OpenBabelc::OBMol_AutomaticPartialCharge;
*SetTitle = *Chemistry::OpenBabelc::OBMol_SetTitle;
*SetFormula = *Chemistry::OpenBabelc::OBMol_SetFormula;
*SetEnergy = *Chemistry::OpenBabelc::OBMol_SetEnergy;
*SetDimension = *Chemistry::OpenBabelc::OBMol_SetDimension;
*SetTotalCharge = *Chemistry::OpenBabelc::OBMol_SetTotalCharge;
*SetTotalSpinMultiplicity = *Chemistry::OpenBabelc::OBMol_SetTotalSpinMultiplicity;
*SetInternalCoord = *Chemistry::OpenBabelc::OBMol_SetInternalCoord;
*SetAutomaticFormalCharge = *Chemistry::OpenBabelc::OBMol_SetAutomaticFormalCharge;
*SetAutomaticPartialCharge = *Chemistry::OpenBabelc::OBMol_SetAutomaticPartialCharge;
*SetAromaticPerceived = *Chemistry::OpenBabelc::OBMol_SetAromaticPerceived;
*SetSSSRPerceived = *Chemistry::OpenBabelc::OBMol_SetSSSRPerceived;
*SetLSSRPerceived = *Chemistry::OpenBabelc::OBMol_SetLSSRPerceived;
*SetRingAtomsAndBondsPerceived = *Chemistry::OpenBabelc::OBMol_SetRingAtomsAndBondsPerceived;
*SetAtomTypesPerceived = *Chemistry::OpenBabelc::OBMol_SetAtomTypesPerceived;
*SetRingTypesPerceived = *Chemistry::OpenBabelc::OBMol_SetRingTypesPerceived;
*SetChainsPerceived = *Chemistry::OpenBabelc::OBMol_SetChainsPerceived;
*SetChiralityPerceived = *Chemistry::OpenBabelc::OBMol_SetChiralityPerceived;
*SetPartialChargesPerceived = *Chemistry::OpenBabelc::OBMol_SetPartialChargesPerceived;
*SetHybridizationPerceived = *Chemistry::OpenBabelc::OBMol_SetHybridizationPerceived;
*SetClosureBondsPerceived = *Chemistry::OpenBabelc::OBMol_SetClosureBondsPerceived;
*SetHydrogensAdded = *Chemistry::OpenBabelc::OBMol_SetHydrogensAdded;
*SetCorrectedForPH = *Chemistry::OpenBabelc::OBMol_SetCorrectedForPH;
*SetSpinMultiplicityAssigned = *Chemistry::OpenBabelc::OBMol_SetSpinMultiplicityAssigned;
*SetIsPatternStructure = *Chemistry::OpenBabelc::OBMol_SetIsPatternStructure;
*SetIsReaction = *Chemistry::OpenBabelc::OBMol_SetIsReaction;
*SetPeriodicMol = *Chemistry::OpenBabelc::OBMol_SetPeriodicMol;
*HasFlag = *Chemistry::OpenBabelc::OBMol_HasFlag;
*SetFlag = *Chemistry::OpenBabelc::OBMol_SetFlag;
*UnsetFlag = *Chemistry::OpenBabelc::OBMol_UnsetFlag;
*SetFlags = *Chemistry::OpenBabelc::OBMol_SetFlags;
*ClassDescription = *Chemistry::OpenBabelc::OBMol_ClassDescription;
*RenumberAtoms = *Chemistry::OpenBabelc::OBMol_RenumberAtoms;
*SetCoordinates = *Chemistry::OpenBabelc::OBMol_SetCoordinates;
*ToInertialFrame = *Chemistry::OpenBabelc::OBMol_ToInertialFrame;
*Translate = *Chemistry::OpenBabelc::OBMol_Translate;
*Rotate = *Chemistry::OpenBabelc::OBMol_Rotate;
*DeleteHydrogens = *Chemistry::OpenBabelc::OBMol_DeleteHydrogens;
*DeletePolarHydrogens = *Chemistry::OpenBabelc::OBMol_DeletePolarHydrogens;
*DeleteNonPolarHydrogens = *Chemistry::OpenBabelc::OBMol_DeleteNonPolarHydrogens;
*DeleteHydrogen = *Chemistry::OpenBabelc::OBMol_DeleteHydrogen;
*AddHydrogens = *Chemistry::OpenBabelc::OBMol_AddHydrogens;
*AddPolarHydrogens = *Chemistry::OpenBabelc::OBMol_AddPolarHydrogens;
*AddNonPolarHydrogens = *Chemistry::OpenBabelc::OBMol_AddNonPolarHydrogens;
*AddNewHydrogens = *Chemistry::OpenBabelc::OBMol_AddNewHydrogens;
*StripSalts = *Chemistry::OpenBabelc::OBMol_StripSalts;
*Separate = *Chemistry::OpenBabelc::OBMol_Separate;
*GetNextFragment = *Chemistry::OpenBabelc::OBMol_GetNextFragment;
*CopySubstructure = *Chemistry::OpenBabelc::OBMol_CopySubstructure;
*ConvertDativeBonds = *Chemistry::OpenBabelc::OBMol_ConvertDativeBonds;
*MakeDativeBonds = *Chemistry::OpenBabelc::OBMol_MakeDativeBonds;
*ConvertZeroBonds = *Chemistry::OpenBabelc::OBMol_ConvertZeroBonds;
*CorrectForPH = *Chemistry::OpenBabelc::OBMol_CorrectForPH;
*AssignSpinMultiplicity = *Chemistry::OpenBabelc::OBMol_AssignSpinMultiplicity;
*AssignTotalChargeToAtoms = *Chemistry::OpenBabelc::OBMol_AssignTotalChargeToAtoms;
*Center = *Chemistry::OpenBabelc::OBMol_Center;
*SetTorsion = *Chemistry::OpenBabelc::OBMol_SetTorsion;
*FindSSSR = *Chemistry::OpenBabelc::OBMol_FindSSSR;
*FindLSSR = *Chemistry::OpenBabelc::OBMol_FindLSSR;
*FindRingAtomsAndBonds = *Chemistry::OpenBabelc::OBMol_FindRingAtomsAndBonds;
*FindChildren = *Chemistry::OpenBabelc::OBMol_FindChildren;
*FindLargestFragment = *Chemistry::OpenBabelc::OBMol_FindLargestFragment;
*ContigFragList = *Chemistry::OpenBabelc::OBMol_ContigFragList;
*Align = *Chemistry::OpenBabelc::OBMol_Align;
*ConnectTheDots = *Chemistry::OpenBabelc::OBMol_ConnectTheDots;
*PerceiveBondOrders = *Chemistry::OpenBabelc::OBMol_PerceiveBondOrders;
*FindAngles = *Chemistry::OpenBabelc::OBMol_FindAngles;
*FindTorsions = *Chemistry::OpenBabelc::OBMol_FindTorsions;
*GetGTDVector = *Chemistry::OpenBabelc::OBMol_GetGTDVector;
*GetGIVector = *Chemistry::OpenBabelc::OBMol_GetGIVector;
*GetGIDVector = *Chemistry::OpenBabelc::OBMol_GetGIDVector;
*Has2D = *Chemistry::OpenBabelc::OBMol_Has2D;
*Has3D = *Chemistry::OpenBabelc::OBMol_Has3D;
*HasNonZeroCoords = *Chemistry::OpenBabelc::OBMol_HasNonZeroCoords;
*HasAromaticPerceived = *Chemistry::OpenBabelc::OBMol_HasAromaticPerceived;
*HasSSSRPerceived = *Chemistry::OpenBabelc::OBMol_HasSSSRPerceived;
*HasLSSRPerceived = *Chemistry::OpenBabelc::OBMol_HasLSSRPerceived;
*HasRingAtomsAndBondsPerceived = *Chemistry::OpenBabelc::OBMol_HasRingAtomsAndBondsPerceived;
*HasAtomTypesPerceived = *Chemistry::OpenBabelc::OBMol_HasAtomTypesPerceived;
*HasRingTypesPerceived = *Chemistry::OpenBabelc::OBMol_HasRingTypesPerceived;
*HasChiralityPerceived = *Chemistry::OpenBabelc::OBMol_HasChiralityPerceived;
*HasPartialChargesPerceived = *Chemistry::OpenBabelc::OBMol_HasPartialChargesPerceived;
*HasHybridizationPerceived = *Chemistry::OpenBabelc::OBMol_HasHybridizationPerceived;
*HasClosureBondsPerceived = *Chemistry::OpenBabelc::OBMol_HasClosureBondsPerceived;
*HasChainsPerceived = *Chemistry::OpenBabelc::OBMol_HasChainsPerceived;
*HasHydrogensAdded = *Chemistry::OpenBabelc::OBMol_HasHydrogensAdded;
*IsCorrectedForPH = *Chemistry::OpenBabelc::OBMol_IsCorrectedForPH;
*HasSpinMultiplicityAssigned = *Chemistry::OpenBabelc::OBMol_HasSpinMultiplicityAssigned;
*IsReaction = *Chemistry::OpenBabelc::OBMol_IsReaction;
*IsPeriodic = *Chemistry::OpenBabelc::OBMol_IsPeriodic;
*Empty = *Chemistry::OpenBabelc::OBMol_Empty;
*NumConformers = *Chemistry::OpenBabelc::OBMol_NumConformers;
*SetConformers = *Chemistry::OpenBabelc::OBMol_SetConformers;
*AddConformer = *Chemistry::OpenBabelc::OBMol_AddConformer;
*SetConformer = *Chemistry::OpenBabelc::OBMol_SetConformer;
*CopyConformer = *Chemistry::OpenBabelc::OBMol_CopyConformer;
*DeleteConformer = *Chemistry::OpenBabelc::OBMol_DeleteConformer;
*GetConformer = *Chemistry::OpenBabelc::OBMol_GetConformer;
*SetEnergies = *Chemistry::OpenBabelc::OBMol_SetEnergies;
*GetEnergies = *Chemistry::OpenBabelc::OBMol_GetEnergies;
*GetEnergy = *Chemistry::OpenBabelc::OBMol_GetEnergy;
*BeginConformer = *Chemistry::OpenBabelc::OBMol_BeginConformer;
*NextConformer = *Chemistry::OpenBabelc::OBMol_NextConformer;
*GetConformers = *Chemistry::OpenBabelc::OBMol_GetConformers;
*BeginAtoms = *Chemistry::OpenBabelc::OBMol_BeginAtoms;
*EndAtoms = *Chemistry::OpenBabelc::OBMol_EndAtoms;
*BeginBonds = *Chemistry::OpenBabelc::OBMol_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::OBMol_EndBonds;
*BeginResidues = *Chemistry::OpenBabelc::OBMol_BeginResidues;
*EndResidues = *Chemistry::OpenBabelc::OBMol_EndResidues;
*BeginAtom = *Chemistry::OpenBabelc::OBMol_BeginAtom;
*NextAtom = *Chemistry::OpenBabelc::OBMol_NextAtom;
*BeginBond = *Chemistry::OpenBabelc::OBMol_BeginBond;
*NextBond = *Chemistry::OpenBabelc::OBMol_NextBond;
*BeginResidue = *Chemistry::OpenBabelc::OBMol_BeginResidue;
*NextResidue = *Chemistry::OpenBabelc::OBMol_NextResidue;
*BeginInternalCoord = *Chemistry::OpenBabelc::OBMol_BeginInternalCoord;
*NextInternalCoord = *Chemistry::OpenBabelc::OBMol_NextInternalCoord;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRing ##############

package Chemistry::OpenBabel::OBRing;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_ring_id_get = *Chemistry::OpenBabelc::OBRing_ring_id_get;
*swig_ring_id_set = *Chemistry::OpenBabelc::OBRing_ring_id_set;
*swig__path_get = *Chemistry::OpenBabelc::OBRing__path_get;
*swig__path_set = *Chemistry::OpenBabelc::OBRing__path_set;
*swig__pathset_get = *Chemistry::OpenBabelc::OBRing__pathset_get;
*swig__pathset_set = *Chemistry::OpenBabelc::OBRing__pathset_set;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRing(@_);
    bless $self, $pkg if defined($self);
}

*Size = *Chemistry::OpenBabelc::OBRing_Size;
*PathSize = *Chemistry::OpenBabelc::OBRing_PathSize;
*IsAromatic = *Chemistry::OpenBabelc::OBRing_IsAromatic;
*SetType = *Chemistry::OpenBabelc::OBRing_SetType;
*GetType = *Chemistry::OpenBabelc::OBRing_GetType;
*GetRootAtom = *Chemistry::OpenBabelc::OBRing_GetRootAtom;
*IsMember = *Chemistry::OpenBabelc::OBRing_IsMember;
*IsInRing = *Chemistry::OpenBabelc::OBRing_IsInRing;
*SetParent = *Chemistry::OpenBabelc::OBRing_SetParent;
*GetParent = *Chemistry::OpenBabelc::OBRing_GetParent;
*findCenterAndNormal = *Chemistry::OpenBabelc::OBRing_findCenterAndNormal;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRing($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRingSearch ##############

package Chemistry::OpenBabel::OBRingSearch;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRingSearch(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRingSearch($self);
        delete $OWNER{$self};
    }
}

*SortRings = *Chemistry::OpenBabelc::OBRingSearch_SortRings;
*RemoveRedundant = *Chemistry::OpenBabelc::OBRingSearch_RemoveRedundant;
*AddRingFromClosure = *Chemistry::OpenBabelc::OBRingSearch_AddRingFromClosure;
*SaveUniqueRing = *Chemistry::OpenBabelc::OBRingSearch_SaveUniqueRing;
*WriteRings = *Chemistry::OpenBabelc::OBRingSearch_WriteRings;
*BeginRings = *Chemistry::OpenBabelc::OBRingSearch_BeginRings;
*EndRings = *Chemistry::OpenBabelc::OBRingSearch_EndRings;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRTree ##############

package Chemistry::OpenBabel::OBRTree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRTree(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRTree($self);
        delete $OWNER{$self};
    }
}

*GetAtomIdx = *Chemistry::OpenBabelc::OBRTree_GetAtomIdx;
*PathToRoot = *Chemistry::OpenBabelc::OBRTree_PathToRoot;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSmartsPattern ##############

package Chemistry::OpenBabel::OBSmartsPattern;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSmartsPattern($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSmartsPattern(@_);
    bless $self, $pkg if defined($self);
}

*Init = *Chemistry::OpenBabelc::OBSmartsPattern_Init;
*GetSMARTS = *Chemistry::OpenBabelc::OBSmartsPattern_GetSMARTS;
*Empty = *Chemistry::OpenBabelc::OBSmartsPattern_Empty;
*IsValid = *Chemistry::OpenBabelc::OBSmartsPattern_IsValid;
*NumAtoms = *Chemistry::OpenBabelc::OBSmartsPattern_NumAtoms;
*NumBonds = *Chemistry::OpenBabelc::OBSmartsPattern_NumBonds;
*GetBond = *Chemistry::OpenBabelc::OBSmartsPattern_GetBond;
*GetAtomicNum = *Chemistry::OpenBabelc::OBSmartsPattern_GetAtomicNum;
*GetCharge = *Chemistry::OpenBabelc::OBSmartsPattern_GetCharge;
*GetVectorBinding = *Chemistry::OpenBabelc::OBSmartsPattern_GetVectorBinding;
*All = *Chemistry::OpenBabelc::OBSmartsPattern_All;
*Single = *Chemistry::OpenBabelc::OBSmartsPattern_Single;
*AllUnique = *Chemistry::OpenBabelc::OBSmartsPattern_AllUnique;
*Match = *Chemistry::OpenBabelc::OBSmartsPattern_Match;
*HasMatch = *Chemistry::OpenBabelc::OBSmartsPattern_HasMatch;
*RestrictedMatch = *Chemistry::OpenBabelc::OBSmartsPattern_RestrictedMatch;
*NumMatches = *Chemistry::OpenBabelc::OBSmartsPattern_NumMatches;
*GetMapList = *Chemistry::OpenBabelc::OBSmartsPattern_GetMapList;
*BeginMList = *Chemistry::OpenBabelc::OBSmartsPattern_BeginMList;
*EndMList = *Chemistry::OpenBabelc::OBSmartsPattern_EndMList;
*GetUMapList = *Chemistry::OpenBabelc::OBSmartsPattern_GetUMapList;
*WriteMapList = *Chemistry::OpenBabelc::OBSmartsPattern_WriteMapList;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSmartsMatcher ##############

package Chemistry::OpenBabel::OBSmartsMatcher;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSmartsMatcher(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSmartsMatcher($self);
        delete $OWNER{$self};
    }
}

*match = *Chemistry::OpenBabelc::OBSmartsMatcher_match;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBSSMatch ##############

package Chemistry::OpenBabel::OBSSMatch;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBSSMatch(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBSSMatch($self);
        delete $OWNER{$self};
    }
}

*Match = *Chemistry::OpenBabelc::OBSSMatch_Match;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::AliasData ##############

package Chemistry::OpenBabel::AliasData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_AliasData(@_);
    bless $self, $pkg if defined($self);
}

*SetAlias = *Chemistry::OpenBabelc::AliasData_SetAlias;
*GetAlias = *Chemistry::OpenBabelc::AliasData_GetAlias;
*GetColor = *Chemistry::OpenBabelc::AliasData_GetColor;
*SetColor = *Chemistry::OpenBabelc::AliasData_SetColor;
*IsExpanded = *Chemistry::OpenBabelc::AliasData_IsExpanded;
*RevertToAliasForm = *Chemistry::OpenBabelc::AliasData_RevertToAliasForm;
*Expand = *Chemistry::OpenBabelc::AliasData_Expand;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_AliasData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBDescriptor ##############

package Chemistry::OpenBabel::OBDescriptor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBPlugin Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Default = *Chemistry::OpenBabelc::OBDescriptor_Default;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBDescriptor(@_);
    bless $self, $pkg if defined($self);
}

*FindType = *Chemistry::OpenBabelc::OBDescriptor_FindType;
*Predict = *Chemistry::OpenBabelc::OBDescriptor_Predict;
*PredictAndSave = *Chemistry::OpenBabelc::OBDescriptor_PredictAndSave;
*GetStringValue = *Chemistry::OpenBabelc::OBDescriptor_GetStringValue;
*Compare = *Chemistry::OpenBabelc::OBDescriptor_Compare;
*Display = *Chemistry::OpenBabelc::OBDescriptor_Display;
*Order = *Chemistry::OpenBabelc::OBDescriptor_Order;
*FilterCompare = *Chemistry::OpenBabelc::OBDescriptor_FilterCompare;
*AddProperties = *Chemistry::OpenBabelc::OBDescriptor_AddProperties;
*DeleteProperties = *Chemistry::OpenBabelc::OBDescriptor_DeleteProperties;
*GetValues = *Chemistry::OpenBabelc::OBDescriptor_GetValues;
*GetIdentifier = *Chemistry::OpenBabelc::OBDescriptor_GetIdentifier;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBDescriptor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::LineSearchType ##############

package Chemistry::OpenBabel::LineSearchType;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Simple = *Chemistry::OpenBabelc::LineSearchType_Simple;
*Newton2Num = *Chemistry::OpenBabelc::LineSearchType_Newton2Num;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_LineSearchType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_LineSearchType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFFParameter ##############

package Chemistry::OpenBabel::OBFFParameter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_a_get = *Chemistry::OpenBabelc::OBFFParameter_a_get;
*swig_a_set = *Chemistry::OpenBabelc::OBFFParameter_a_set;
*swig_b_get = *Chemistry::OpenBabelc::OBFFParameter_b_get;
*swig_b_set = *Chemistry::OpenBabelc::OBFFParameter_b_set;
*swig_c_get = *Chemistry::OpenBabelc::OBFFParameter_c_get;
*swig_c_set = *Chemistry::OpenBabelc::OBFFParameter_c_set;
*swig_d_get = *Chemistry::OpenBabelc::OBFFParameter_d_get;
*swig_d_set = *Chemistry::OpenBabelc::OBFFParameter_d_set;
*swig__a_get = *Chemistry::OpenBabelc::OBFFParameter__a_get;
*swig__a_set = *Chemistry::OpenBabelc::OBFFParameter__a_set;
*swig__b_get = *Chemistry::OpenBabelc::OBFFParameter__b_get;
*swig__b_set = *Chemistry::OpenBabelc::OBFFParameter__b_set;
*swig__c_get = *Chemistry::OpenBabelc::OBFFParameter__c_get;
*swig__c_set = *Chemistry::OpenBabelc::OBFFParameter__c_set;
*swig__d_get = *Chemistry::OpenBabelc::OBFFParameter__d_get;
*swig__d_set = *Chemistry::OpenBabelc::OBFFParameter__d_set;
*swig__ipar_get = *Chemistry::OpenBabelc::OBFFParameter__ipar_get;
*swig__ipar_set = *Chemistry::OpenBabelc::OBFFParameter__ipar_set;
*swig__dpar_get = *Chemistry::OpenBabelc::OBFFParameter__dpar_get;
*swig__dpar_set = *Chemistry::OpenBabelc::OBFFParameter__dpar_set;
*clear = *Chemistry::OpenBabelc::OBFFParameter_clear;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFFParameter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFFParameter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFFCalculation2 ##############

package Chemistry::OpenBabel::OBFFCalculation2;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_energy_get = *Chemistry::OpenBabelc::OBFFCalculation2_energy_get;
*swig_energy_set = *Chemistry::OpenBabelc::OBFFCalculation2_energy_set;
*swig_a_get = *Chemistry::OpenBabelc::OBFFCalculation2_a_get;
*swig_a_set = *Chemistry::OpenBabelc::OBFFCalculation2_a_set;
*swig_b_get = *Chemistry::OpenBabelc::OBFFCalculation2_b_get;
*swig_b_set = *Chemistry::OpenBabelc::OBFFCalculation2_b_set;
*swig_idx_a_get = *Chemistry::OpenBabelc::OBFFCalculation2_idx_a_get;
*swig_idx_a_set = *Chemistry::OpenBabelc::OBFFCalculation2_idx_a_set;
*swig_idx_b_get = *Chemistry::OpenBabelc::OBFFCalculation2_idx_b_get;
*swig_idx_b_set = *Chemistry::OpenBabelc::OBFFCalculation2_idx_b_set;
*swig_pos_a_get = *Chemistry::OpenBabelc::OBFFCalculation2_pos_a_get;
*swig_pos_a_set = *Chemistry::OpenBabelc::OBFFCalculation2_pos_a_set;
*swig_pos_b_get = *Chemistry::OpenBabelc::OBFFCalculation2_pos_b_get;
*swig_pos_b_set = *Chemistry::OpenBabelc::OBFFCalculation2_pos_b_set;
*swig_force_a_get = *Chemistry::OpenBabelc::OBFFCalculation2_force_a_get;
*swig_force_a_set = *Chemistry::OpenBabelc::OBFFCalculation2_force_a_set;
*swig_force_b_get = *Chemistry::OpenBabelc::OBFFCalculation2_force_b_get;
*swig_force_b_set = *Chemistry::OpenBabelc::OBFFCalculation2_force_b_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFFCalculation2($self);
        delete $OWNER{$self};
    }
}

*SetupPointers = *Chemistry::OpenBabelc::OBFFCalculation2_SetupPointers;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFFCalculation2(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFFCalculation3 ##############

package Chemistry::OpenBabel::OBFFCalculation3;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBFFCalculation2 Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_c_get = *Chemistry::OpenBabelc::OBFFCalculation3_c_get;
*swig_c_set = *Chemistry::OpenBabelc::OBFFCalculation3_c_set;
*swig_idx_c_get = *Chemistry::OpenBabelc::OBFFCalculation3_idx_c_get;
*swig_idx_c_set = *Chemistry::OpenBabelc::OBFFCalculation3_idx_c_set;
*swig_pos_c_get = *Chemistry::OpenBabelc::OBFFCalculation3_pos_c_get;
*swig_pos_c_set = *Chemistry::OpenBabelc::OBFFCalculation3_pos_c_set;
*swig_force_c_get = *Chemistry::OpenBabelc::OBFFCalculation3_force_c_get;
*swig_force_c_set = *Chemistry::OpenBabelc::OBFFCalculation3_force_c_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFFCalculation3($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFFCalculation3(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFFCalculation4 ##############

package Chemistry::OpenBabel::OBFFCalculation4;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBFFCalculation3 Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_d_get = *Chemistry::OpenBabelc::OBFFCalculation4_d_get;
*swig_d_set = *Chemistry::OpenBabelc::OBFFCalculation4_d_set;
*swig_idx_d_get = *Chemistry::OpenBabelc::OBFFCalculation4_idx_d_get;
*swig_idx_d_set = *Chemistry::OpenBabelc::OBFFCalculation4_idx_d_set;
*swig_pos_d_get = *Chemistry::OpenBabelc::OBFFCalculation4_pos_d_get;
*swig_pos_d_set = *Chemistry::OpenBabelc::OBFFCalculation4_pos_d_set;
*swig_force_d_get = *Chemistry::OpenBabelc::OBFFCalculation4_force_d_get;
*swig_force_d_set = *Chemistry::OpenBabelc::OBFFCalculation4_force_d_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFFCalculation4($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFFCalculation4(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFFConstraint ##############

package Chemistry::OpenBabel::OBFFConstraint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*swig_factor_get = *Chemistry::OpenBabelc::OBFFConstraint_factor_get;
*swig_factor_set = *Chemistry::OpenBabelc::OBFFConstraint_factor_set;
*swig_constraint_value_get = *Chemistry::OpenBabelc::OBFFConstraint_constraint_value_get;
*swig_constraint_value_set = *Chemistry::OpenBabelc::OBFFConstraint_constraint_value_set;
*swig_rab0_get = *Chemistry::OpenBabelc::OBFFConstraint_rab0_get;
*swig_rab0_set = *Chemistry::OpenBabelc::OBFFConstraint_rab0_set;
*swig_rbc0_get = *Chemistry::OpenBabelc::OBFFConstraint_rbc0_get;
*swig_rbc0_set = *Chemistry::OpenBabelc::OBFFConstraint_rbc0_set;
*swig_type_get = *Chemistry::OpenBabelc::OBFFConstraint_type_get;
*swig_type_set = *Chemistry::OpenBabelc::OBFFConstraint_type_set;
*swig_ia_get = *Chemistry::OpenBabelc::OBFFConstraint_ia_get;
*swig_ia_set = *Chemistry::OpenBabelc::OBFFConstraint_ia_set;
*swig_ib_get = *Chemistry::OpenBabelc::OBFFConstraint_ib_get;
*swig_ib_set = *Chemistry::OpenBabelc::OBFFConstraint_ib_set;
*swig_ic_get = *Chemistry::OpenBabelc::OBFFConstraint_ic_get;
*swig_ic_set = *Chemistry::OpenBabelc::OBFFConstraint_ic_set;
*swig_id_get = *Chemistry::OpenBabelc::OBFFConstraint_id_get;
*swig_id_set = *Chemistry::OpenBabelc::OBFFConstraint_id_set;
*swig_a_get = *Chemistry::OpenBabelc::OBFFConstraint_a_get;
*swig_a_set = *Chemistry::OpenBabelc::OBFFConstraint_a_set;
*swig_b_get = *Chemistry::OpenBabelc::OBFFConstraint_b_get;
*swig_b_set = *Chemistry::OpenBabelc::OBFFConstraint_b_set;
*swig_c_get = *Chemistry::OpenBabelc::OBFFConstraint_c_get;
*swig_c_set = *Chemistry::OpenBabelc::OBFFConstraint_c_set;
*swig_d_get = *Chemistry::OpenBabelc::OBFFConstraint_d_get;
*swig_d_set = *Chemistry::OpenBabelc::OBFFConstraint_d_set;
*swig_grada_get = *Chemistry::OpenBabelc::OBFFConstraint_grada_get;
*swig_grada_set = *Chemistry::OpenBabelc::OBFFConstraint_grada_set;
*swig_gradb_get = *Chemistry::OpenBabelc::OBFFConstraint_gradb_get;
*swig_gradb_set = *Chemistry::OpenBabelc::OBFFConstraint_gradb_set;
*swig_gradc_get = *Chemistry::OpenBabelc::OBFFConstraint_gradc_get;
*swig_gradc_set = *Chemistry::OpenBabelc::OBFFConstraint_gradc_set;
*swig_gradd_get = *Chemistry::OpenBabelc::OBFFConstraint_gradd_get;
*swig_gradd_set = *Chemistry::OpenBabelc::OBFFConstraint_gradd_set;
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFFConstraint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFFConstraint($self);
        delete $OWNER{$self};
    }
}

*GetGradient = *Chemistry::OpenBabelc::OBFFConstraint_GetGradient;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBFFConstraints ##############

package Chemistry::OpenBabel::OBFFConstraints;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBFFConstraints(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBFFConstraints($self);
        delete $OWNER{$self};
    }
}

*Clear = *Chemistry::OpenBabelc::OBFFConstraints_Clear;
*GetConstraintEnergy = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintEnergy;
*GetGradient = *Chemistry::OpenBabelc::OBFFConstraints_GetGradient;
*Setup = *Chemistry::OpenBabelc::OBFFConstraints_Setup;
*SetFactor = *Chemistry::OpenBabelc::OBFFConstraints_SetFactor;
*AddIgnore = *Chemistry::OpenBabelc::OBFFConstraints_AddIgnore;
*AddAtomConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddAtomConstraint;
*AddAtomXConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddAtomXConstraint;
*AddAtomYConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddAtomYConstraint;
*AddAtomZConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddAtomZConstraint;
*AddDistanceConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddDistanceConstraint;
*AddAngleConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddAngleConstraint;
*AddTorsionConstraint = *Chemistry::OpenBabelc::OBFFConstraints_AddTorsionConstraint;
*DeleteConstraint = *Chemistry::OpenBabelc::OBFFConstraints_DeleteConstraint;
*GetFactor = *Chemistry::OpenBabelc::OBFFConstraints_GetFactor;
*Size = *Chemistry::OpenBabelc::OBFFConstraints_Size;
*GetConstraintType = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintType;
*GetConstraintValue = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintValue;
*GetConstraintAtomA = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintAtomA;
*GetConstraintAtomB = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintAtomB;
*GetConstraintAtomC = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintAtomC;
*GetConstraintAtomD = *Chemistry::OpenBabelc::OBFFConstraints_GetConstraintAtomD;
*IsIgnored = *Chemistry::OpenBabelc::OBFFConstraints_IsIgnored;
*IsFixed = *Chemistry::OpenBabelc::OBFFConstraints_IsFixed;
*IsXFixed = *Chemistry::OpenBabelc::OBFFConstraints_IsXFixed;
*IsYFixed = *Chemistry::OpenBabelc::OBFFConstraints_IsYFixed;
*IsZFixed = *Chemistry::OpenBabelc::OBFFConstraints_IsZFixed;
*GetIgnoredBitVec = *Chemistry::OpenBabelc::OBFFConstraints_GetIgnoredBitVec;
*GetFixedBitVec = *Chemistry::OpenBabelc::OBFFConstraints_GetFixedBitVec;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBForceField ##############

package Chemistry::OpenBabel::OBForceField;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBPlugin Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Default = *Chemistry::OpenBabelc::OBForceField_Default;
*FindType = *Chemistry::OpenBabelc::OBForceField_FindType;
*MakeNewInstance = *Chemistry::OpenBabelc::OBForceField_MakeNewInstance;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBForceField($self);
        delete $OWNER{$self};
    }
}

*FindForceField = *Chemistry::OpenBabelc::OBForceField_FindForceField;
*SetParameterFile = *Chemistry::OpenBabelc::OBForceField_SetParameterFile;
*GetUnit = *Chemistry::OpenBabelc::OBForceField_GetUnit;
*HasAnalyticalGradients = *Chemistry::OpenBabelc::OBForceField_HasAnalyticalGradients;
*Setup = *Chemistry::OpenBabelc::OBForceField_Setup;
*ParseParamFile = *Chemistry::OpenBabelc::OBForceField_ParseParamFile;
*SetTypes = *Chemistry::OpenBabelc::OBForceField_SetTypes;
*SetFormalCharges = *Chemistry::OpenBabelc::OBForceField_SetFormalCharges;
*SetPartialCharges = *Chemistry::OpenBabelc::OBForceField_SetPartialCharges;
*SetupCalculations = *Chemistry::OpenBabelc::OBForceField_SetupCalculations;
*SetupPointers = *Chemistry::OpenBabelc::OBForceField_SetupPointers;
*IsSetupNeeded = *Chemistry::OpenBabelc::OBForceField_IsSetupNeeded;
*GetAtomTypes = *Chemistry::OpenBabelc::OBForceField_GetAtomTypes;
*GetPartialCharges = *Chemistry::OpenBabelc::OBForceField_GetPartialCharges;
*GetCoordinates = *Chemistry::OpenBabelc::OBForceField_GetCoordinates;
*UpdateCoordinates = *Chemistry::OpenBabelc::OBForceField_UpdateCoordinates;
*GetConformers = *Chemistry::OpenBabelc::OBForceField_GetConformers;
*UpdateConformers = *Chemistry::OpenBabelc::OBForceField_UpdateConformers;
*SetCoordinates = *Chemistry::OpenBabelc::OBForceField_SetCoordinates;
*SetConformers = *Chemistry::OpenBabelc::OBForceField_SetConformers;
*GetGrid = *Chemistry::OpenBabelc::OBForceField_GetGrid;
*AddIntraGroup = *Chemistry::OpenBabelc::OBForceField_AddIntraGroup;
*AddInterGroup = *Chemistry::OpenBabelc::OBForceField_AddInterGroup;
*AddInterGroups = *Chemistry::OpenBabelc::OBForceField_AddInterGroups;
*ClearGroups = *Chemistry::OpenBabelc::OBForceField_ClearGroups;
*HasGroups = *Chemistry::OpenBabelc::OBForceField_HasGroups;
*EnableCutOff = *Chemistry::OpenBabelc::OBForceField_EnableCutOff;
*IsCutOffEnabled = *Chemistry::OpenBabelc::OBForceField_IsCutOffEnabled;
*SetVDWCutOff = *Chemistry::OpenBabelc::OBForceField_SetVDWCutOff;
*GetVDWCutOff = *Chemistry::OpenBabelc::OBForceField_GetVDWCutOff;
*SetElectrostaticCutOff = *Chemistry::OpenBabelc::OBForceField_SetElectrostaticCutOff;
*GetElectrostaticCutOff = *Chemistry::OpenBabelc::OBForceField_GetElectrostaticCutOff;
*SetDielectricConstant = *Chemistry::OpenBabelc::OBForceField_SetDielectricConstant;
*GetDielectricConstant = *Chemistry::OpenBabelc::OBForceField_GetDielectricConstant;
*SetUpdateFrequency = *Chemistry::OpenBabelc::OBForceField_SetUpdateFrequency;
*GetUpdateFrequency = *Chemistry::OpenBabelc::OBForceField_GetUpdateFrequency;
*UpdatePairsSimple = *Chemistry::OpenBabelc::OBForceField_UpdatePairsSimple;
*GetNumPairs = *Chemistry::OpenBabelc::OBForceField_GetNumPairs;
*GetNumElectrostaticPairs = *Chemistry::OpenBabelc::OBForceField_GetNumElectrostaticPairs;
*GetNumVDWPairs = *Chemistry::OpenBabelc::OBForceField_GetNumVDWPairs;
*EnableAllPairs = *Chemistry::OpenBabelc::OBForceField_EnableAllPairs;
*GetGradient = *Chemistry::OpenBabelc::OBForceField_GetGradient;
*GetGradientPtr = *Chemistry::OpenBabelc::OBForceField_GetGradientPtr;
*Energy = *Chemistry::OpenBabelc::OBForceField_Energy;
*E_Bond = *Chemistry::OpenBabelc::OBForceField_E_Bond;
*E_Angle = *Chemistry::OpenBabelc::OBForceField_E_Angle;
*E_StrBnd = *Chemistry::OpenBabelc::OBForceField_E_StrBnd;
*E_Torsion = *Chemistry::OpenBabelc::OBForceField_E_Torsion;
*E_OOP = *Chemistry::OpenBabelc::OBForceField_E_OOP;
*E_VDW = *Chemistry::OpenBabelc::OBForceField_E_VDW;
*E_Electrostatic = *Chemistry::OpenBabelc::OBForceField_E_Electrostatic;
*PrintTypes = *Chemistry::OpenBabelc::OBForceField_PrintTypes;
*PrintFormalCharges = *Chemistry::OpenBabelc::OBForceField_PrintFormalCharges;
*PrintPartialCharges = *Chemistry::OpenBabelc::OBForceField_PrintPartialCharges;
*PrintVelocities = *Chemistry::OpenBabelc::OBForceField_PrintVelocities;
*SetLogFile = *Chemistry::OpenBabelc::OBForceField_SetLogFile;
*SetLogLevel = *Chemistry::OpenBabelc::OBForceField_SetLogLevel;
*GetLogLevel = *Chemistry::OpenBabelc::OBForceField_GetLogLevel;
*OBFFLog = *Chemistry::OpenBabelc::OBForceField_OBFFLog;
*DistanceGeometry = *Chemistry::OpenBabelc::OBForceField_DistanceGeometry;
*SystematicRotorSearch = *Chemistry::OpenBabelc::OBForceField_SystematicRotorSearch;
*SystematicRotorSearchInitialize = *Chemistry::OpenBabelc::OBForceField_SystematicRotorSearchInitialize;
*SystematicRotorSearchNextConformer = *Chemistry::OpenBabelc::OBForceField_SystematicRotorSearchNextConformer;
*RandomRotorSearch = *Chemistry::OpenBabelc::OBForceField_RandomRotorSearch;
*RandomRotorSearchInitialize = *Chemistry::OpenBabelc::OBForceField_RandomRotorSearchInitialize;
*RandomRotorSearchNextConformer = *Chemistry::OpenBabelc::OBForceField_RandomRotorSearchNextConformer;
*WeightedRotorSearch = *Chemistry::OpenBabelc::OBForceField_WeightedRotorSearch;
*SetLineSearchType = *Chemistry::OpenBabelc::OBForceField_SetLineSearchType;
*GetLineSearchType = *Chemistry::OpenBabelc::OBForceField_GetLineSearchType;
*LineSearch = *Chemistry::OpenBabelc::OBForceField_LineSearch;
*Newton2NumLineSearch = *Chemistry::OpenBabelc::OBForceField_Newton2NumLineSearch;
*LineSearchTakeStep = *Chemistry::OpenBabelc::OBForceField_LineSearchTakeStep;
*SteepestDescent = *Chemistry::OpenBabelc::OBForceField_SteepestDescent;
*SteepestDescentInitialize = *Chemistry::OpenBabelc::OBForceField_SteepestDescentInitialize;
*SteepestDescentTakeNSteps = *Chemistry::OpenBabelc::OBForceField_SteepestDescentTakeNSteps;
*ConjugateGradients = *Chemistry::OpenBabelc::OBForceField_ConjugateGradients;
*ConjugateGradientsInitialize = *Chemistry::OpenBabelc::OBForceField_ConjugateGradientsInitialize;
*ConjugateGradientsTakeNSteps = *Chemistry::OpenBabelc::OBForceField_ConjugateGradientsTakeNSteps;
*GenerateVelocities = *Chemistry::OpenBabelc::OBForceField_GenerateVelocities;
*CorrectVelocities = *Chemistry::OpenBabelc::OBForceField_CorrectVelocities;
*MolecularDynamicsTakeNSteps = *Chemistry::OpenBabelc::OBForceField_MolecularDynamicsTakeNSteps;
*GetConstraints = *Chemistry::OpenBabelc::OBForceField_GetConstraints;
*SetConstraints = *Chemistry::OpenBabelc::OBForceField_SetConstraints;
*SetFixAtom = *Chemistry::OpenBabelc::OBForceField_SetFixAtom;
*UnsetFixAtom = *Chemistry::OpenBabelc::OBForceField_UnsetFixAtom;
*SetIgnoreAtom = *Chemistry::OpenBabelc::OBForceField_SetIgnoreAtom;
*UnsetIgnoreAtom = *Chemistry::OpenBabelc::OBForceField_UnsetIgnoreAtom;
*IgnoreCalculation = *Chemistry::OpenBabelc::OBForceField_IgnoreCalculation;
*DetectExplosion = *Chemistry::OpenBabelc::OBForceField_DetectExplosion;
*ValidateLineSearch = *Chemistry::OpenBabelc::OBForceField_ValidateLineSearch;
*ValidateSteepestDescent = *Chemistry::OpenBabelc::OBForceField_ValidateSteepestDescent;
*ValidateConjugateGradients = *Chemistry::OpenBabelc::OBForceField_ValidateConjugateGradients;
*Validate = *Chemistry::OpenBabelc::OBForceField_Validate;
*ValidateGradients = *Chemistry::OpenBabelc::OBForceField_ValidateGradients;
*ValidateGradientError = *Chemistry::OpenBabelc::OBForceField_ValidateGradientError;
*VectorBondDerivative = *Chemistry::OpenBabelc::OBForceField_VectorBondDerivative;
*VectorDistanceDerivative = *Chemistry::OpenBabelc::OBForceField_VectorDistanceDerivative;
*VectorLengthDerivative = *Chemistry::OpenBabelc::OBForceField_VectorLengthDerivative;
*VectorAngleDerivative = *Chemistry::OpenBabelc::OBForceField_VectorAngleDerivative;
*VectorOOPDerivative = *Chemistry::OpenBabelc::OBForceField_VectorOOPDerivative;
*VectorTorsionDerivative = *Chemistry::OpenBabelc::OBForceField_VectorTorsionDerivative;
*VectorSubtract = *Chemistry::OpenBabelc::OBForceField_VectorSubtract;
*VectorAdd = *Chemistry::OpenBabelc::OBForceField_VectorAdd;
*VectorDivide = *Chemistry::OpenBabelc::OBForceField_VectorDivide;
*VectorMultiply = *Chemistry::OpenBabelc::OBForceField_VectorMultiply;
*VectorSelfMultiply = *Chemistry::OpenBabelc::OBForceField_VectorSelfMultiply;
*VectorNormalize = *Chemistry::OpenBabelc::OBForceField_VectorNormalize;
*VectorCopy = *Chemistry::OpenBabelc::OBForceField_VectorCopy;
*VectorLength = *Chemistry::OpenBabelc::OBForceField_VectorLength;
*VectorDistance = *Chemistry::OpenBabelc::OBForceField_VectorDistance;
*VectorAngle = *Chemistry::OpenBabelc::OBForceField_VectorAngle;
*VectorTorsion = *Chemistry::OpenBabelc::OBForceField_VectorTorsion;
*VectorOOP = *Chemistry::OpenBabelc::OBForceField_VectorOOP;
*VectorClear = *Chemistry::OpenBabelc::OBForceField_VectorClear;
*VectorDot = *Chemistry::OpenBabelc::OBForceField_VectorDot;
*VectorCross = *Chemistry::OpenBabelc::OBForceField_VectorCross;
*PrintVector = *Chemistry::OpenBabelc::OBForceField_PrintVector;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBBuilder ##############

package Chemistry::OpenBabel::OBBuilder;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBBuilder(@_);
    bless $self, $pkg if defined($self);
}

*Build = *Chemistry::OpenBabelc::OBBuilder_Build;
*SetKeepRings = *Chemistry::OpenBabelc::OBBuilder_SetKeepRings;
*UnsetKeepRings = *Chemistry::OpenBabelc::OBBuilder_UnsetKeepRings;
*AddRingFragment = *Chemistry::OpenBabelc::OBBuilder_AddRingFragment;
*LoadFragments = *Chemistry::OpenBabelc::OBBuilder_LoadFragments;
*GetFragmentCoord = *Chemistry::OpenBabelc::OBBuilder_GetFragmentCoord;
*GetNewBondVector = *Chemistry::OpenBabelc::OBBuilder_GetNewBondVector;
*Connect = *Chemistry::OpenBabelc::OBBuilder_Connect;
*Swap = *Chemistry::OpenBabelc::OBBuilder_Swap;
*CorrectStereoBonds = *Chemistry::OpenBabelc::OBBuilder_CorrectStereoBonds;
*CorrectStereoAtoms = *Chemistry::OpenBabelc::OBBuilder_CorrectStereoAtoms;
*IsSpiroAtom = *Chemistry::OpenBabelc::OBBuilder_IsSpiroAtom;
*GetFragment = *Chemistry::OpenBabelc::OBBuilder_GetFragment;
*AddNbrs = *Chemistry::OpenBabelc::OBBuilder_AddNbrs;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBBuilder($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBOp ##############

package Chemistry::OpenBabel::OBOp;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBPlugin Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
*Default = *Chemistry::OpenBabelc::OBOp_Default;
*FindType = *Chemistry::OpenBabelc::OBOp_FindType;
*Do = *Chemistry::OpenBabelc::OBOp_Do;
*WorksWith = *Chemistry::OpenBabelc::OBOp_WorksWith;
*ProcessVec = *Chemistry::OpenBabelc::OBOp_ProcessVec;
*OpOptions = *Chemistry::OpenBabelc::OBOp_OpOptions;
*DoOps = *Chemistry::OpenBabelc::OBOp_DoOps;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBOp($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotorRule ##############

package Chemistry::OpenBabel::OBRotorRule;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotorRule(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotorRule($self);
        delete $OWNER{$self};
    }
}

*IsValid = *Chemistry::OpenBabelc::OBRotorRule_IsValid;
*GetReferenceAtoms = *Chemistry::OpenBabelc::OBRotorRule_GetReferenceAtoms;
*SetDelta = *Chemistry::OpenBabelc::OBRotorRule_SetDelta;
*GetDelta = *Chemistry::OpenBabelc::OBRotorRule_GetDelta;
*GetTorsionVals = *Chemistry::OpenBabelc::OBRotorRule_GetTorsionVals;
*GetSmartsString = *Chemistry::OpenBabelc::OBRotorRule_GetSmartsString;
*GetSmartsPattern = *Chemistry::OpenBabelc::OBRotorRule_GetSmartsPattern;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotorRules ##############

package Chemistry::OpenBabel::OBRotorRules;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGlobalDataBase Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotorRules(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotorRules($self);
        delete $OWNER{$self};
    }
}

*SetFilename = *Chemistry::OpenBabelc::OBRotorRules_SetFilename;
*GetRotorIncrements = *Chemistry::OpenBabelc::OBRotorRules_GetRotorIncrements;
*Quiet = *Chemistry::OpenBabelc::OBRotorRules_Quiet;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotor ##############

package Chemistry::OpenBabel::OBRotor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotor($self);
        delete $OWNER{$self};
    }
}

*SetBond = *Chemistry::OpenBabelc::OBRotor_SetBond;
*SetRings = *Chemistry::OpenBabelc::OBRotor_SetRings;
*SetIdx = *Chemistry::OpenBabelc::OBRotor_SetIdx;
*SetDihedralAtoms = *Chemistry::OpenBabelc::OBRotor_SetDihedralAtoms;
*SetRotAtoms = *Chemistry::OpenBabelc::OBRotor_SetRotAtoms;
*SetTorsionValues = *Chemistry::OpenBabelc::OBRotor_SetTorsionValues;
*SetFixedBonds = *Chemistry::OpenBabelc::OBRotor_SetFixedBonds;
*SetToAngle = *Chemistry::OpenBabelc::OBRotor_SetToAngle;
*SetRotor = *Chemistry::OpenBabelc::OBRotor_SetRotor;
*Precompute = *Chemistry::OpenBabelc::OBRotor_Precompute;
*Precalc = *Chemistry::OpenBabelc::OBRotor_Precalc;
*Set = *Chemistry::OpenBabelc::OBRotor_Set;
*GetBond = *Chemistry::OpenBabelc::OBRotor_GetBond;
*Size = *Chemistry::OpenBabelc::OBRotor_Size;
*GetIdx = *Chemistry::OpenBabelc::OBRotor_GetIdx;
*GetDihedralAtoms = *Chemistry::OpenBabelc::OBRotor_GetDihedralAtoms;
*GetTorsionValues = *Chemistry::OpenBabelc::OBRotor_GetTorsionValues;
*GetFixedBonds = *Chemistry::OpenBabelc::OBRotor_GetFixedBonds;
*CalcTorsion = *Chemistry::OpenBabelc::OBRotor_CalcTorsion;
*CalcBondLength = *Chemistry::OpenBabelc::OBRotor_CalcBondLength;
*BeginTorIncrement = *Chemistry::OpenBabelc::OBRotor_BeginTorIncrement;
*EndTorIncrement = *Chemistry::OpenBabelc::OBRotor_EndTorIncrement;
*RemoveSymTorsionValues = *Chemistry::OpenBabelc::OBRotor_RemoveSymTorsionValues;
*SetDelta = *Chemistry::OpenBabelc::OBRotor_SetDelta;
*GetDelta = *Chemistry::OpenBabelc::OBRotor_GetDelta;
*GetFixedAtoms = *Chemistry::OpenBabelc::OBRotor_GetFixedAtoms;
*SetFixedAtoms = *Chemistry::OpenBabelc::OBRotor_SetFixedAtoms;
*GetEvalAtoms = *Chemistry::OpenBabelc::OBRotor_GetEvalAtoms;
*SetEvalAtoms = *Chemistry::OpenBabelc::OBRotor_SetEvalAtoms;
*GetRotAtoms = *Chemistry::OpenBabelc::OBRotor_GetRotAtoms;
*GetResolution = *Chemistry::OpenBabelc::OBRotor_GetResolution;
*SetNumCoords = *Chemistry::OpenBabelc::OBRotor_SetNumCoords;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotorList ##############

package Chemistry::OpenBabel::OBRotorList;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotorList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotorList($self);
        delete $OWNER{$self};
    }
}

*Clear = *Chemistry::OpenBabelc::OBRotorList_Clear;
*Size = *Chemistry::OpenBabelc::OBRotorList_Size;
*IsFixedBond = *Chemistry::OpenBabelc::OBRotorList_IsFixedBond;
*HasFixedBonds = *Chemistry::OpenBabelc::OBRotorList_HasFixedBonds;
*RemoveSymVals = *Chemistry::OpenBabelc::OBRotorList_RemoveSymVals;
*HasRingRotors = *Chemistry::OpenBabelc::OBRotorList_HasRingRotors;
*Setup = *Chemistry::OpenBabelc::OBRotorList_Setup;
*SetFixedBonds = *Chemistry::OpenBabelc::OBRotorList_SetFixedBonds;
*Init = *Chemistry::OpenBabelc::OBRotorList_Init;
*SetQuiet = *Chemistry::OpenBabelc::OBRotorList_SetQuiet;
*SetRotAtoms = *Chemistry::OpenBabelc::OBRotorList_SetRotAtoms;
*FindRotors = *Chemistry::OpenBabelc::OBRotorList_FindRotors;
*SetEvalAtoms = *Chemistry::OpenBabelc::OBRotorList_SetEvalAtoms;
*AssignTorVals = *Chemistry::OpenBabelc::OBRotorList_AssignTorVals;
*BeginRotor = *Chemistry::OpenBabelc::OBRotorList_BeginRotor;
*NextRotor = *Chemistry::OpenBabelc::OBRotorList_NextRotor;
*BeginRotors = *Chemistry::OpenBabelc::OBRotorList_BeginRotors;
*EndRotors = *Chemistry::OpenBabelc::OBRotorList_EndRotors;
*IdentifyEvalAtoms = *Chemistry::OpenBabelc::OBRotorList_IdentifyEvalAtoms;
*SetFixAtoms = *Chemistry::OpenBabelc::OBRotorList_SetFixAtoms;
*HasFixedAtoms = *Chemistry::OpenBabelc::OBRotorList_HasFixedAtoms;
*IgnoreSymmetryRemoval = *Chemistry::OpenBabelc::OBRotorList_IgnoreSymmetryRemoval;
*SetRotAtomsByFix = *Chemistry::OpenBabelc::OBRotorList_SetRotAtomsByFix;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::rotor_digit ##############

package Chemistry::OpenBabel::rotor_digit;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_rotor_digit(@_);
    bless $self, $pkg if defined($self);
}

*set_size = *Chemistry::OpenBabelc::rotor_digit_set_size;
*set_state = *Chemistry::OpenBabelc::rotor_digit_set_state;
*get_state = *Chemistry::OpenBabelc::rotor_digit_get_state;
*size = *Chemistry::OpenBabelc::rotor_digit_size;
*next = *Chemistry::OpenBabelc::rotor_digit_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_rotor_digit($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotorKeys ##############

package Chemistry::OpenBabel::OBRotorKeys;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotorKeys(@_);
    bless $self, $pkg if defined($self);
}

*Clear = *Chemistry::OpenBabelc::OBRotorKeys_Clear;
*NumKeys = *Chemistry::OpenBabelc::OBRotorKeys_NumKeys;
*AddRotor = *Chemistry::OpenBabelc::OBRotorKeys_AddRotor;
*Next = *Chemistry::OpenBabelc::OBRotorKeys_Next;
*GetKey = *Chemistry::OpenBabelc::OBRotorKeys_GetKey;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotorKeys($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBRotamerList ##############

package Chemistry::OpenBabel::OBRotamerList;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel::OBGenericData Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBRotamerList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBRotamerList($self);
        delete $OWNER{$self};
    }
}

*Setup = *Chemistry::OpenBabelc::OBRotamerList_Setup;
*NumRotors = *Chemistry::OpenBabelc::OBRotamerList_NumRotors;
*NumRotamers = *Chemistry::OpenBabelc::OBRotamerList_NumRotamers;
*AddRotamer = *Chemistry::OpenBabelc::OBRotamerList_AddRotamer;
*AddRotamers = *Chemistry::OpenBabelc::OBRotamerList_AddRotamers;
*GetReferenceArray = *Chemistry::OpenBabelc::OBRotamerList_GetReferenceArray;
*BeginRotamer = *Chemistry::OpenBabelc::OBRotamerList_BeginRotamer;
*EndRotamer = *Chemistry::OpenBabelc::OBRotamerList_EndRotamer;
*CreateConformerList = *Chemistry::OpenBabelc::OBRotamerList_CreateConformerList;
*ExpandConformerList = *Chemistry::OpenBabelc::OBRotamerList_ExpandConformerList;
*SetCurrentCoordinates = *Chemistry::OpenBabelc::OBRotamerList_SetCurrentCoordinates;
*SetBaseCoordinateSets = *Chemistry::OpenBabelc::OBRotamerList_SetBaseCoordinateSets;
*NumBaseCoordinateSets = *Chemistry::OpenBabelc::OBRotamerList_NumBaseCoordinateSets;
*GetBaseCoordinateSet = *Chemistry::OpenBabelc::OBRotamerList_GetBaseCoordinateSet;
*NumAtoms = *Chemistry::OpenBabelc::OBRotamerList_NumAtoms;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolAtomIter ##############

package Chemistry::OpenBabel::_OBMolAtomIter;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolAtomIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolAtomIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolAtomIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolAtomIter_inc;
*deref = *Chemistry::OpenBabelc::_OBMolAtomIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBMolAtomIter___ref__;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBMolAtomIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBMolAtomIter_Visit_set;
*__eq__ = *Chemistry::OpenBabelc::_OBMolAtomIter___eq__;
*Duplicate = *Chemistry::OpenBabelc::_OBMolAtomIter_Duplicate;
*SetIdx = *Chemistry::OpenBabelc::_OBMolAtomIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBMolAtomIter_SetId;
*SetHyb = *Chemistry::OpenBabelc::_OBMolAtomIter_SetHyb;
*SetAtomicNum = *Chemistry::OpenBabelc::_OBMolAtomIter_SetAtomicNum;
*SetIsotope = *Chemistry::OpenBabelc::_OBMolAtomIter_SetIsotope;
*SetImplicitHCount = *Chemistry::OpenBabelc::_OBMolAtomIter_SetImplicitHCount;
*SetFormalCharge = *Chemistry::OpenBabelc::_OBMolAtomIter_SetFormalCharge;
*SetSpinMultiplicity = *Chemistry::OpenBabelc::_OBMolAtomIter_SetSpinMultiplicity;
*SetType = *Chemistry::OpenBabelc::_OBMolAtomIter_SetType;
*SetPartialCharge = *Chemistry::OpenBabelc::_OBMolAtomIter_SetPartialCharge;
*SetVector = *Chemistry::OpenBabelc::_OBMolAtomIter_SetVector;
*SetCoordPtr = *Chemistry::OpenBabelc::_OBMolAtomIter_SetCoordPtr;
*SetResidue = *Chemistry::OpenBabelc::_OBMolAtomIter_SetResidue;
*SetParent = *Chemistry::OpenBabelc::_OBMolAtomIter_SetParent;
*SetAromatic = *Chemistry::OpenBabelc::_OBMolAtomIter_SetAromatic;
*SetInRing = *Chemistry::OpenBabelc::_OBMolAtomIter_SetInRing;
*ClearCoordPtr = *Chemistry::OpenBabelc::_OBMolAtomIter_ClearCoordPtr;
*GetFormalCharge = *Chemistry::OpenBabelc::_OBMolAtomIter_GetFormalCharge;
*GetAtomicNum = *Chemistry::OpenBabelc::_OBMolAtomIter_GetAtomicNum;
*GetIsotope = *Chemistry::OpenBabelc::_OBMolAtomIter_GetIsotope;
*GetSpinMultiplicity = *Chemistry::OpenBabelc::_OBMolAtomIter_GetSpinMultiplicity;
*GetAtomicMass = *Chemistry::OpenBabelc::_OBMolAtomIter_GetAtomicMass;
*GetExactMass = *Chemistry::OpenBabelc::_OBMolAtomIter_GetExactMass;
*GetIdx = *Chemistry::OpenBabelc::_OBMolAtomIter_GetIdx;
*GetIndex = *Chemistry::OpenBabelc::_OBMolAtomIter_GetIndex;
*GetId = *Chemistry::OpenBabelc::_OBMolAtomIter_GetId;
*GetCoordinateIdx = *Chemistry::OpenBabelc::_OBMolAtomIter_GetCoordinateIdx;
*GetExplicitDegree = *Chemistry::OpenBabelc::_OBMolAtomIter_GetExplicitDegree;
*GetTotalDegree = *Chemistry::OpenBabelc::_OBMolAtomIter_GetTotalDegree;
*GetExplicitValence = *Chemistry::OpenBabelc::_OBMolAtomIter_GetExplicitValence;
*GetTotalValence = *Chemistry::OpenBabelc::_OBMolAtomIter_GetTotalValence;
*GetHyb = *Chemistry::OpenBabelc::_OBMolAtomIter_GetHyb;
*GetImplicitHCount = *Chemistry::OpenBabelc::_OBMolAtomIter_GetImplicitHCount;
*GetHvyDegree = *Chemistry::OpenBabelc::_OBMolAtomIter_GetHvyDegree;
*GetHeteroDegree = *Chemistry::OpenBabelc::_OBMolAtomIter_GetHeteroDegree;
*GetType = *Chemistry::OpenBabelc::_OBMolAtomIter_GetType;
*GetX = *Chemistry::OpenBabelc::_OBMolAtomIter_GetX;
*GetY = *Chemistry::OpenBabelc::_OBMolAtomIter_GetY;
*GetZ = *Chemistry::OpenBabelc::_OBMolAtomIter_GetZ;
*x = *Chemistry::OpenBabelc::_OBMolAtomIter_x;
*y = *Chemistry::OpenBabelc::_OBMolAtomIter_y;
*z = *Chemistry::OpenBabelc::_OBMolAtomIter_z;
*GetCoordinate = *Chemistry::OpenBabelc::_OBMolAtomIter_GetCoordinate;
*GetVector = *Chemistry::OpenBabelc::_OBMolAtomIter_GetVector;
*GetPartialCharge = *Chemistry::OpenBabelc::_OBMolAtomIter_GetPartialCharge;
*GetResidue = *Chemistry::OpenBabelc::_OBMolAtomIter_GetResidue;
*GetParent = *Chemistry::OpenBabelc::_OBMolAtomIter_GetParent;
*GetNewBondVector = *Chemistry::OpenBabelc::_OBMolAtomIter_GetNewBondVector;
*GetBond = *Chemistry::OpenBabelc::_OBMolAtomIter_GetBond;
*BeginBonds = *Chemistry::OpenBabelc::_OBMolAtomIter_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::_OBMolAtomIter_EndBonds;
*BeginBond = *Chemistry::OpenBabelc::_OBMolAtomIter_BeginBond;
*NextBond = *Chemistry::OpenBabelc::_OBMolAtomIter_NextBond;
*BeginNbrAtom = *Chemistry::OpenBabelc::_OBMolAtomIter_BeginNbrAtom;
*NextNbrAtom = *Chemistry::OpenBabelc::_OBMolAtomIter_NextNbrAtom;
*GetDistance = *Chemistry::OpenBabelc::_OBMolAtomIter_GetDistance;
*GetAngle = *Chemistry::OpenBabelc::_OBMolAtomIter_GetAngle;
*NewResidue = *Chemistry::OpenBabelc::_OBMolAtomIter_NewResidue;
*AddResidue = *Chemistry::OpenBabelc::_OBMolAtomIter_AddResidue;
*DeleteResidue = *Chemistry::OpenBabelc::_OBMolAtomIter_DeleteResidue;
*AddBond = *Chemistry::OpenBabelc::_OBMolAtomIter_AddBond;
*InsertBond = *Chemistry::OpenBabelc::_OBMolAtomIter_InsertBond;
*DeleteBond = *Chemistry::OpenBabelc::_OBMolAtomIter_DeleteBond;
*ClearBond = *Chemistry::OpenBabelc::_OBMolAtomIter_ClearBond;
*HtoMethyl = *Chemistry::OpenBabelc::_OBMolAtomIter_HtoMethyl;
*SetHybAndGeom = *Chemistry::OpenBabelc::_OBMolAtomIter_SetHybAndGeom;
*CountFreeOxygens = *Chemistry::OpenBabelc::_OBMolAtomIter_CountFreeOxygens;
*CountFreeSulfurs = *Chemistry::OpenBabelc::_OBMolAtomIter_CountFreeSulfurs;
*ExplicitHydrogenCount = *Chemistry::OpenBabelc::_OBMolAtomIter_ExplicitHydrogenCount;
*MemberOfRingCount = *Chemistry::OpenBabelc::_OBMolAtomIter_MemberOfRingCount;
*MemberOfRingSize = *Chemistry::OpenBabelc::_OBMolAtomIter_MemberOfRingSize;
*CountRingBonds = *Chemistry::OpenBabelc::_OBMolAtomIter_CountRingBonds;
*SmallestBondAngle = *Chemistry::OpenBabelc::_OBMolAtomIter_SmallestBondAngle;
*AverageBondAngle = *Chemistry::OpenBabelc::_OBMolAtomIter_AverageBondAngle;
*LewisAcidBaseCounts = *Chemistry::OpenBabelc::_OBMolAtomIter_LewisAcidBaseCounts;
*HasResidue = *Chemistry::OpenBabelc::_OBMolAtomIter_HasResidue;
*IsHetAtom = *Chemistry::OpenBabelc::_OBMolAtomIter_IsHetAtom;
*IsElement = *Chemistry::OpenBabelc::_OBMolAtomIter_IsElement;
*IsAromatic = *Chemistry::OpenBabelc::_OBMolAtomIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBMolAtomIter_IsInRing;
*IsInRingSize = *Chemistry::OpenBabelc::_OBMolAtomIter_IsInRingSize;
*IsHeteroatom = *Chemistry::OpenBabelc::_OBMolAtomIter_IsHeteroatom;
*IsConnected = *Chemistry::OpenBabelc::_OBMolAtomIter_IsConnected;
*IsOneThree = *Chemistry::OpenBabelc::_OBMolAtomIter_IsOneThree;
*IsOneFour = *Chemistry::OpenBabelc::_OBMolAtomIter_IsOneFour;
*IsCarboxylOxygen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsCarboxylOxygen;
*IsPhosphateOxygen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsPhosphateOxygen;
*IsSulfateOxygen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsSulfateOxygen;
*IsNitroOxygen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsNitroOxygen;
*IsAmideNitrogen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsAmideNitrogen;
*IsPolarHydrogen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsPolarHydrogen;
*IsNonPolarHydrogen = *Chemistry::OpenBabelc::_OBMolAtomIter_IsNonPolarHydrogen;
*IsAromaticNOxide = *Chemistry::OpenBabelc::_OBMolAtomIter_IsAromaticNOxide;
*IsChiral = *Chemistry::OpenBabelc::_OBMolAtomIter_IsChiral;
*IsPeriodic = *Chemistry::OpenBabelc::_OBMolAtomIter_IsPeriodic;
*IsAxial = *Chemistry::OpenBabelc::_OBMolAtomIter_IsAxial;
*IsHbondAcceptor = *Chemistry::OpenBabelc::_OBMolAtomIter_IsHbondAcceptor;
*IsHbondAcceptorSimple = *Chemistry::OpenBabelc::_OBMolAtomIter_IsHbondAcceptorSimple;
*IsHbondDonor = *Chemistry::OpenBabelc::_OBMolAtomIter_IsHbondDonor;
*IsHbondDonorH = *Chemistry::OpenBabelc::_OBMolAtomIter_IsHbondDonorH;
*IsMetal = *Chemistry::OpenBabelc::_OBMolAtomIter_IsMetal;
*HasAlphaBetaUnsat = *Chemistry::OpenBabelc::_OBMolAtomIter_HasAlphaBetaUnsat;
*HasBondOfOrder = *Chemistry::OpenBabelc::_OBMolAtomIter_HasBondOfOrder;
*CountBondsOfOrder = *Chemistry::OpenBabelc::_OBMolAtomIter_CountBondsOfOrder;
*HighestBondOrder = *Chemistry::OpenBabelc::_OBMolAtomIter_HighestBondOrder;
*HasNonSingleBond = *Chemistry::OpenBabelc::_OBMolAtomIter_HasNonSingleBond;
*HasSingleBond = *Chemistry::OpenBabelc::_OBMolAtomIter_HasSingleBond;
*HasDoubleBond = *Chemistry::OpenBabelc::_OBMolAtomIter_HasDoubleBond;
*HasAromaticBond = *Chemistry::OpenBabelc::_OBMolAtomIter_HasAromaticBond;
*MatchesSMARTS = *Chemistry::OpenBabelc::_OBMolAtomIter_MatchesSMARTS;
*Clear = *Chemistry::OpenBabelc::_OBMolAtomIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBMolAtomIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBMolAtomIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBMolAtomIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBMolAtomIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBMolAtomIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBMolAtomIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBMolAtomIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBMolAtomIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBMolAtomIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBMolAtomIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBMolAtomIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBMolAtomIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolAtomDFSIter ##############

package Chemistry::OpenBabel::_OBMolAtomDFSIter;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolAtomDFSIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolAtomDFSIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_inc;
*deref = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBMolAtomDFSIter___ref__;
*_next = *Chemistry::OpenBabelc::_OBMolAtomDFSIter__next;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_Visit_set;
*__eq__ = *Chemistry::OpenBabelc::_OBMolAtomDFSIter___eq__;
*Duplicate = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_Duplicate;
*SetIdx = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetId;
*SetHyb = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetHyb;
*SetAtomicNum = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetAtomicNum;
*SetIsotope = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetIsotope;
*SetImplicitHCount = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetImplicitHCount;
*SetFormalCharge = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetFormalCharge;
*SetSpinMultiplicity = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetSpinMultiplicity;
*SetType = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetType;
*SetPartialCharge = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetPartialCharge;
*SetVector = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetVector;
*SetCoordPtr = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetCoordPtr;
*SetResidue = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetResidue;
*SetParent = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetParent;
*SetAromatic = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetAromatic;
*SetInRing = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetInRing;
*ClearCoordPtr = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_ClearCoordPtr;
*GetFormalCharge = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetFormalCharge;
*GetAtomicNum = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetAtomicNum;
*GetIsotope = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetIsotope;
*GetSpinMultiplicity = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetSpinMultiplicity;
*GetAtomicMass = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetAtomicMass;
*GetExactMass = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetExactMass;
*GetIdx = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetIdx;
*GetIndex = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetIndex;
*GetId = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetId;
*GetCoordinateIdx = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetCoordinateIdx;
*GetExplicitDegree = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetExplicitDegree;
*GetTotalDegree = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetTotalDegree;
*GetExplicitValence = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetExplicitValence;
*GetTotalValence = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetTotalValence;
*GetHyb = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetHyb;
*GetImplicitHCount = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetImplicitHCount;
*GetHvyDegree = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetHvyDegree;
*GetHeteroDegree = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetHeteroDegree;
*GetType = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetType;
*GetX = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetX;
*GetY = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetY;
*GetZ = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetZ;
*x = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_x;
*y = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_y;
*z = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_z;
*GetCoordinate = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetCoordinate;
*GetVector = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetVector;
*GetPartialCharge = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetPartialCharge;
*GetResidue = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetResidue;
*GetParent = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetParent;
*GetNewBondVector = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetNewBondVector;
*GetBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetBond;
*BeginBonds = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_EndBonds;
*BeginBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_BeginBond;
*NextBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_NextBond;
*BeginNbrAtom = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_BeginNbrAtom;
*NextNbrAtom = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_NextNbrAtom;
*GetDistance = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetDistance;
*GetAngle = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetAngle;
*NewResidue = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_NewResidue;
*AddResidue = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_AddResidue;
*DeleteResidue = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_DeleteResidue;
*AddBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_AddBond;
*InsertBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_InsertBond;
*DeleteBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_DeleteBond;
*ClearBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_ClearBond;
*HtoMethyl = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HtoMethyl;
*SetHybAndGeom = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetHybAndGeom;
*CountFreeOxygens = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_CountFreeOxygens;
*CountFreeSulfurs = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_CountFreeSulfurs;
*ExplicitHydrogenCount = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_ExplicitHydrogenCount;
*MemberOfRingCount = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_MemberOfRingCount;
*MemberOfRingSize = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_MemberOfRingSize;
*CountRingBonds = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_CountRingBonds;
*SmallestBondAngle = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SmallestBondAngle;
*AverageBondAngle = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_AverageBondAngle;
*LewisAcidBaseCounts = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_LewisAcidBaseCounts;
*HasResidue = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasResidue;
*IsHetAtom = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsHetAtom;
*IsElement = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsElement;
*IsAromatic = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsInRing;
*IsInRingSize = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsInRingSize;
*IsHeteroatom = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsHeteroatom;
*IsConnected = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsConnected;
*IsOneThree = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsOneThree;
*IsOneFour = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsOneFour;
*IsCarboxylOxygen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsCarboxylOxygen;
*IsPhosphateOxygen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsPhosphateOxygen;
*IsSulfateOxygen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsSulfateOxygen;
*IsNitroOxygen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsNitroOxygen;
*IsAmideNitrogen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsAmideNitrogen;
*IsPolarHydrogen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsPolarHydrogen;
*IsNonPolarHydrogen = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsNonPolarHydrogen;
*IsAromaticNOxide = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsAromaticNOxide;
*IsChiral = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsChiral;
*IsPeriodic = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsPeriodic;
*IsAxial = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsAxial;
*IsHbondAcceptor = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsHbondAcceptor;
*IsHbondAcceptorSimple = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsHbondAcceptorSimple;
*IsHbondDonor = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsHbondDonor;
*IsHbondDonorH = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsHbondDonorH;
*IsMetal = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_IsMetal;
*HasAlphaBetaUnsat = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasAlphaBetaUnsat;
*HasBondOfOrder = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasBondOfOrder;
*CountBondsOfOrder = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_CountBondsOfOrder;
*HighestBondOrder = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HighestBondOrder;
*HasNonSingleBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasNonSingleBond;
*HasSingleBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasSingleBond;
*HasDoubleBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasDoubleBond;
*HasAromaticBond = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasAromaticBond;
*MatchesSMARTS = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_MatchesSMARTS;
*Clear = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBMolAtomDFSIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolAtomBFSIter ##############

package Chemistry::OpenBabel::_OBMolAtomBFSIter;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolAtomBFSIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolAtomBFSIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_inc;
*deref = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBMolAtomBFSIter___ref__;
*CurrentDepth = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_CurrentDepth;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_Visit_set;
*__eq__ = *Chemistry::OpenBabelc::_OBMolAtomBFSIter___eq__;
*Duplicate = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_Duplicate;
*SetIdx = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetId;
*SetHyb = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetHyb;
*SetAtomicNum = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetAtomicNum;
*SetIsotope = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetIsotope;
*SetImplicitHCount = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetImplicitHCount;
*SetFormalCharge = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetFormalCharge;
*SetSpinMultiplicity = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetSpinMultiplicity;
*SetType = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetType;
*SetPartialCharge = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetPartialCharge;
*SetVector = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetVector;
*SetCoordPtr = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetCoordPtr;
*SetResidue = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetResidue;
*SetParent = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetParent;
*SetAromatic = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetAromatic;
*SetInRing = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetInRing;
*ClearCoordPtr = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_ClearCoordPtr;
*GetFormalCharge = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetFormalCharge;
*GetAtomicNum = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetAtomicNum;
*GetIsotope = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetIsotope;
*GetSpinMultiplicity = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetSpinMultiplicity;
*GetAtomicMass = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetAtomicMass;
*GetExactMass = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetExactMass;
*GetIdx = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetIdx;
*GetIndex = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetIndex;
*GetId = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetId;
*GetCoordinateIdx = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetCoordinateIdx;
*GetExplicitDegree = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetExplicitDegree;
*GetTotalDegree = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetTotalDegree;
*GetExplicitValence = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetExplicitValence;
*GetTotalValence = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetTotalValence;
*GetHyb = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetHyb;
*GetImplicitHCount = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetImplicitHCount;
*GetHvyDegree = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetHvyDegree;
*GetHeteroDegree = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetHeteroDegree;
*GetType = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetType;
*GetX = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetX;
*GetY = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetY;
*GetZ = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetZ;
*x = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_x;
*y = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_y;
*z = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_z;
*GetCoordinate = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetCoordinate;
*GetVector = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetVector;
*GetPartialCharge = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetPartialCharge;
*GetResidue = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetResidue;
*GetParent = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetParent;
*GetNewBondVector = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetNewBondVector;
*GetBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetBond;
*BeginBonds = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_EndBonds;
*BeginBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_BeginBond;
*NextBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_NextBond;
*BeginNbrAtom = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_BeginNbrAtom;
*NextNbrAtom = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_NextNbrAtom;
*GetDistance = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetDistance;
*GetAngle = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetAngle;
*NewResidue = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_NewResidue;
*AddResidue = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_AddResidue;
*DeleteResidue = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_DeleteResidue;
*AddBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_AddBond;
*InsertBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_InsertBond;
*DeleteBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_DeleteBond;
*ClearBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_ClearBond;
*HtoMethyl = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HtoMethyl;
*SetHybAndGeom = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetHybAndGeom;
*CountFreeOxygens = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_CountFreeOxygens;
*CountFreeSulfurs = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_CountFreeSulfurs;
*ExplicitHydrogenCount = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_ExplicitHydrogenCount;
*MemberOfRingCount = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_MemberOfRingCount;
*MemberOfRingSize = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_MemberOfRingSize;
*CountRingBonds = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_CountRingBonds;
*SmallestBondAngle = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SmallestBondAngle;
*AverageBondAngle = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_AverageBondAngle;
*LewisAcidBaseCounts = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_LewisAcidBaseCounts;
*HasResidue = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasResidue;
*IsHetAtom = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsHetAtom;
*IsElement = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsElement;
*IsAromatic = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsInRing;
*IsInRingSize = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsInRingSize;
*IsHeteroatom = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsHeteroatom;
*IsConnected = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsConnected;
*IsOneThree = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsOneThree;
*IsOneFour = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsOneFour;
*IsCarboxylOxygen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsCarboxylOxygen;
*IsPhosphateOxygen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsPhosphateOxygen;
*IsSulfateOxygen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsSulfateOxygen;
*IsNitroOxygen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsNitroOxygen;
*IsAmideNitrogen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsAmideNitrogen;
*IsPolarHydrogen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsPolarHydrogen;
*IsNonPolarHydrogen = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsNonPolarHydrogen;
*IsAromaticNOxide = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsAromaticNOxide;
*IsChiral = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsChiral;
*IsPeriodic = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsPeriodic;
*IsAxial = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsAxial;
*IsHbondAcceptor = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsHbondAcceptor;
*IsHbondAcceptorSimple = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsHbondAcceptorSimple;
*IsHbondDonor = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsHbondDonor;
*IsHbondDonorH = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsHbondDonorH;
*IsMetal = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_IsMetal;
*HasAlphaBetaUnsat = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasAlphaBetaUnsat;
*HasBondOfOrder = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasBondOfOrder;
*CountBondsOfOrder = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_CountBondsOfOrder;
*HighestBondOrder = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HighestBondOrder;
*HasNonSingleBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasNonSingleBond;
*HasSingleBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasSingleBond;
*HasDoubleBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasDoubleBond;
*HasAromaticBond = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasAromaticBond;
*MatchesSMARTS = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_MatchesSMARTS;
*Clear = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBMolAtomBFSIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBMolBondBFSIter ##############

package Chemistry::OpenBabel::OBMolBondBFSIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBMolBondBFSIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBMolBondBFSIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::OBMolBondBFSIter_good;
*inc = *Chemistry::OpenBabelc::OBMolBondBFSIter_inc;
*deref = *Chemistry::OpenBabelc::OBMolBondBFSIter_deref;
*__ref__ = *Chemistry::OpenBabelc::OBMolBondBFSIter___ref__;
*CurrentDepth = *Chemistry::OpenBabelc::OBMolBondBFSIter_CurrentDepth;
*swig_Visit_get = *Chemistry::OpenBabelc::OBMolBondBFSIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::OBMolBondBFSIter_Visit_set;
*SetIdx = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetId;
*SetBondOrder = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetBondOrder;
*SetBegin = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetBegin;
*SetEnd = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetEnd;
*SetParent = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetParent;
*SetLength = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetLength;
*Set = *Chemistry::OpenBabelc::OBMolBondBFSIter_Set;
*SetAromatic = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetAromatic;
*SetWedge = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetWedge;
*SetHash = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetHash;
*SetWedgeOrHash = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetWedgeOrHash;
*SetInRing = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetInRing;
*SetClosure = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetClosure;
*GetIdx = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetIdx;
*GetId = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetId;
*GetBondOrder = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetBondOrder;
*GetFlags = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetFlags;
*GetBeginAtomIdx = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetBeginAtomIdx;
*GetEndAtomIdx = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetEndAtomIdx;
*GetBeginAtom = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetBeginAtom;
*GetEndAtom = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetEndAtom;
*GetNbrAtom = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetNbrAtom;
*GetParent = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetParent;
*GetEquibLength = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetEquibLength;
*GetLength = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetLength;
*GetNbrAtomIdx = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetNbrAtomIdx;
*FindSmallestRing = *Chemistry::OpenBabelc::OBMolBondBFSIter_FindSmallestRing;
*IsAromatic = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsInRing;
*IsRotor = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsRotor;
*IsPeriodic = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsPeriodic;
*IsAmide = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsAmide;
*IsPrimaryAmide = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsPrimaryAmide;
*IsSecondaryAmide = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsSecondaryAmide;
*IsTertiaryAmide = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsTertiaryAmide;
*IsEster = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsEster;
*IsCarbonyl = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsCarbonyl;
*IsClosure = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsClosure;
*IsWedge = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsWedge;
*IsHash = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsHash;
*IsWedgeOrHash = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsWedgeOrHash;
*IsCisOrTrans = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsCisOrTrans;
*IsDoubleBondGeometry = *Chemistry::OpenBabelc::OBMolBondBFSIter_IsDoubleBondGeometry;
*Clear = *Chemistry::OpenBabelc::OBMolBondBFSIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::OBMolBondBFSIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::OBMolBondBFSIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::OBMolBondBFSIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::OBMolBondBFSIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::OBMolBondBFSIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::OBMolBondBFSIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::OBMolBondBFSIter_DataSize;
*GetData = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::OBMolBondBFSIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::OBMolBondBFSIter_BeginData;
*EndData = *Chemistry::OpenBabelc::OBMolBondBFSIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolBondIter ##############

package Chemistry::OpenBabel::_OBMolBondIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolBondIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolBondIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolBondIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolBondIter_inc;
*deref = *Chemistry::OpenBabelc::_OBMolBondIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBMolBondIter___ref__;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBMolBondIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBMolBondIter_Visit_set;
*SetIdx = *Chemistry::OpenBabelc::_OBMolBondIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBMolBondIter_SetId;
*SetBondOrder = *Chemistry::OpenBabelc::_OBMolBondIter_SetBondOrder;
*SetBegin = *Chemistry::OpenBabelc::_OBMolBondIter_SetBegin;
*SetEnd = *Chemistry::OpenBabelc::_OBMolBondIter_SetEnd;
*SetParent = *Chemistry::OpenBabelc::_OBMolBondIter_SetParent;
*SetLength = *Chemistry::OpenBabelc::_OBMolBondIter_SetLength;
*Set = *Chemistry::OpenBabelc::_OBMolBondIter_Set;
*SetAromatic = *Chemistry::OpenBabelc::_OBMolBondIter_SetAromatic;
*SetWedge = *Chemistry::OpenBabelc::_OBMolBondIter_SetWedge;
*SetHash = *Chemistry::OpenBabelc::_OBMolBondIter_SetHash;
*SetWedgeOrHash = *Chemistry::OpenBabelc::_OBMolBondIter_SetWedgeOrHash;
*SetInRing = *Chemistry::OpenBabelc::_OBMolBondIter_SetInRing;
*SetClosure = *Chemistry::OpenBabelc::_OBMolBondIter_SetClosure;
*GetIdx = *Chemistry::OpenBabelc::_OBMolBondIter_GetIdx;
*GetId = *Chemistry::OpenBabelc::_OBMolBondIter_GetId;
*GetBondOrder = *Chemistry::OpenBabelc::_OBMolBondIter_GetBondOrder;
*GetFlags = *Chemistry::OpenBabelc::_OBMolBondIter_GetFlags;
*GetBeginAtomIdx = *Chemistry::OpenBabelc::_OBMolBondIter_GetBeginAtomIdx;
*GetEndAtomIdx = *Chemistry::OpenBabelc::_OBMolBondIter_GetEndAtomIdx;
*GetBeginAtom = *Chemistry::OpenBabelc::_OBMolBondIter_GetBeginAtom;
*GetEndAtom = *Chemistry::OpenBabelc::_OBMolBondIter_GetEndAtom;
*GetNbrAtom = *Chemistry::OpenBabelc::_OBMolBondIter_GetNbrAtom;
*GetParent = *Chemistry::OpenBabelc::_OBMolBondIter_GetParent;
*GetEquibLength = *Chemistry::OpenBabelc::_OBMolBondIter_GetEquibLength;
*GetLength = *Chemistry::OpenBabelc::_OBMolBondIter_GetLength;
*GetNbrAtomIdx = *Chemistry::OpenBabelc::_OBMolBondIter_GetNbrAtomIdx;
*FindSmallestRing = *Chemistry::OpenBabelc::_OBMolBondIter_FindSmallestRing;
*IsAromatic = *Chemistry::OpenBabelc::_OBMolBondIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBMolBondIter_IsInRing;
*IsRotor = *Chemistry::OpenBabelc::_OBMolBondIter_IsRotor;
*IsPeriodic = *Chemistry::OpenBabelc::_OBMolBondIter_IsPeriodic;
*IsAmide = *Chemistry::OpenBabelc::_OBMolBondIter_IsAmide;
*IsPrimaryAmide = *Chemistry::OpenBabelc::_OBMolBondIter_IsPrimaryAmide;
*IsSecondaryAmide = *Chemistry::OpenBabelc::_OBMolBondIter_IsSecondaryAmide;
*IsTertiaryAmide = *Chemistry::OpenBabelc::_OBMolBondIter_IsTertiaryAmide;
*IsEster = *Chemistry::OpenBabelc::_OBMolBondIter_IsEster;
*IsCarbonyl = *Chemistry::OpenBabelc::_OBMolBondIter_IsCarbonyl;
*IsClosure = *Chemistry::OpenBabelc::_OBMolBondIter_IsClosure;
*IsWedge = *Chemistry::OpenBabelc::_OBMolBondIter_IsWedge;
*IsHash = *Chemistry::OpenBabelc::_OBMolBondIter_IsHash;
*IsWedgeOrHash = *Chemistry::OpenBabelc::_OBMolBondIter_IsWedgeOrHash;
*IsCisOrTrans = *Chemistry::OpenBabelc::_OBMolBondIter_IsCisOrTrans;
*IsDoubleBondGeometry = *Chemistry::OpenBabelc::_OBMolBondIter_IsDoubleBondGeometry;
*Clear = *Chemistry::OpenBabelc::_OBMolBondIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBMolBondIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBMolBondIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBMolBondIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBMolBondIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBMolBondIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBMolBondIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBMolBondIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBMolBondIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBMolBondIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBMolBondIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBMolBondIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBMolBondIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBAtomAtomIter ##############

package Chemistry::OpenBabel::_OBAtomAtomIter;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBAtomAtomIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBAtomAtomIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBAtomAtomIter_good;
*inc = *Chemistry::OpenBabelc::_OBAtomAtomIter_inc;
*deref = *Chemistry::OpenBabelc::_OBAtomAtomIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBAtomAtomIter___ref__;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBAtomAtomIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBAtomAtomIter_Visit_set;
*__eq__ = *Chemistry::OpenBabelc::_OBAtomAtomIter___eq__;
*Duplicate = *Chemistry::OpenBabelc::_OBAtomAtomIter_Duplicate;
*SetIdx = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetId;
*SetHyb = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetHyb;
*SetAtomicNum = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetAtomicNum;
*SetIsotope = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetIsotope;
*SetImplicitHCount = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetImplicitHCount;
*SetFormalCharge = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetFormalCharge;
*SetSpinMultiplicity = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetSpinMultiplicity;
*SetType = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetType;
*SetPartialCharge = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetPartialCharge;
*SetVector = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetVector;
*SetCoordPtr = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetCoordPtr;
*SetResidue = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetResidue;
*SetParent = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetParent;
*SetAromatic = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetAromatic;
*SetInRing = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetInRing;
*ClearCoordPtr = *Chemistry::OpenBabelc::_OBAtomAtomIter_ClearCoordPtr;
*GetFormalCharge = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetFormalCharge;
*GetAtomicNum = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetAtomicNum;
*GetIsotope = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetIsotope;
*GetSpinMultiplicity = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetSpinMultiplicity;
*GetAtomicMass = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetAtomicMass;
*GetExactMass = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetExactMass;
*GetIdx = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetIdx;
*GetIndex = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetIndex;
*GetId = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetId;
*GetCoordinateIdx = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetCoordinateIdx;
*GetExplicitDegree = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetExplicitDegree;
*GetTotalDegree = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetTotalDegree;
*GetExplicitValence = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetExplicitValence;
*GetTotalValence = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetTotalValence;
*GetHyb = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetHyb;
*GetImplicitHCount = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetImplicitHCount;
*GetHvyDegree = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetHvyDegree;
*GetHeteroDegree = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetHeteroDegree;
*GetType = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetType;
*GetX = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetX;
*GetY = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetY;
*GetZ = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetZ;
*x = *Chemistry::OpenBabelc::_OBAtomAtomIter_x;
*y = *Chemistry::OpenBabelc::_OBAtomAtomIter_y;
*z = *Chemistry::OpenBabelc::_OBAtomAtomIter_z;
*GetCoordinate = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetCoordinate;
*GetVector = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetVector;
*GetPartialCharge = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetPartialCharge;
*GetResidue = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetResidue;
*GetParent = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetParent;
*GetNewBondVector = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetNewBondVector;
*GetBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetBond;
*BeginBonds = *Chemistry::OpenBabelc::_OBAtomAtomIter_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::_OBAtomAtomIter_EndBonds;
*BeginBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_BeginBond;
*NextBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_NextBond;
*BeginNbrAtom = *Chemistry::OpenBabelc::_OBAtomAtomIter_BeginNbrAtom;
*NextNbrAtom = *Chemistry::OpenBabelc::_OBAtomAtomIter_NextNbrAtom;
*GetDistance = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetDistance;
*GetAngle = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetAngle;
*NewResidue = *Chemistry::OpenBabelc::_OBAtomAtomIter_NewResidue;
*AddResidue = *Chemistry::OpenBabelc::_OBAtomAtomIter_AddResidue;
*DeleteResidue = *Chemistry::OpenBabelc::_OBAtomAtomIter_DeleteResidue;
*AddBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_AddBond;
*InsertBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_InsertBond;
*DeleteBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_DeleteBond;
*ClearBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_ClearBond;
*HtoMethyl = *Chemistry::OpenBabelc::_OBAtomAtomIter_HtoMethyl;
*SetHybAndGeom = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetHybAndGeom;
*CountFreeOxygens = *Chemistry::OpenBabelc::_OBAtomAtomIter_CountFreeOxygens;
*CountFreeSulfurs = *Chemistry::OpenBabelc::_OBAtomAtomIter_CountFreeSulfurs;
*ExplicitHydrogenCount = *Chemistry::OpenBabelc::_OBAtomAtomIter_ExplicitHydrogenCount;
*MemberOfRingCount = *Chemistry::OpenBabelc::_OBAtomAtomIter_MemberOfRingCount;
*MemberOfRingSize = *Chemistry::OpenBabelc::_OBAtomAtomIter_MemberOfRingSize;
*CountRingBonds = *Chemistry::OpenBabelc::_OBAtomAtomIter_CountRingBonds;
*SmallestBondAngle = *Chemistry::OpenBabelc::_OBAtomAtomIter_SmallestBondAngle;
*AverageBondAngle = *Chemistry::OpenBabelc::_OBAtomAtomIter_AverageBondAngle;
*LewisAcidBaseCounts = *Chemistry::OpenBabelc::_OBAtomAtomIter_LewisAcidBaseCounts;
*HasResidue = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasResidue;
*IsHetAtom = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsHetAtom;
*IsElement = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsElement;
*IsAromatic = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsInRing;
*IsInRingSize = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsInRingSize;
*IsHeteroatom = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsHeteroatom;
*IsConnected = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsConnected;
*IsOneThree = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsOneThree;
*IsOneFour = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsOneFour;
*IsCarboxylOxygen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsCarboxylOxygen;
*IsPhosphateOxygen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsPhosphateOxygen;
*IsSulfateOxygen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsSulfateOxygen;
*IsNitroOxygen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsNitroOxygen;
*IsAmideNitrogen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsAmideNitrogen;
*IsPolarHydrogen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsPolarHydrogen;
*IsNonPolarHydrogen = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsNonPolarHydrogen;
*IsAromaticNOxide = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsAromaticNOxide;
*IsChiral = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsChiral;
*IsPeriodic = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsPeriodic;
*IsAxial = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsAxial;
*IsHbondAcceptor = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsHbondAcceptor;
*IsHbondAcceptorSimple = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsHbondAcceptorSimple;
*IsHbondDonor = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsHbondDonor;
*IsHbondDonorH = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsHbondDonorH;
*IsMetal = *Chemistry::OpenBabelc::_OBAtomAtomIter_IsMetal;
*HasAlphaBetaUnsat = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasAlphaBetaUnsat;
*HasBondOfOrder = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasBondOfOrder;
*CountBondsOfOrder = *Chemistry::OpenBabelc::_OBAtomAtomIter_CountBondsOfOrder;
*HighestBondOrder = *Chemistry::OpenBabelc::_OBAtomAtomIter_HighestBondOrder;
*HasNonSingleBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasNonSingleBond;
*HasSingleBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasSingleBond;
*HasDoubleBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasDoubleBond;
*HasAromaticBond = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasAromaticBond;
*MatchesSMARTS = *Chemistry::OpenBabelc::_OBAtomAtomIter_MatchesSMARTS;
*Clear = *Chemistry::OpenBabelc::_OBAtomAtomIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBAtomAtomIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBAtomAtomIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBAtomAtomIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBAtomAtomIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBAtomAtomIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBAtomAtomIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBAtomAtomIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBAtomAtomIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBAtomAtomIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBAtomAtomIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBAtomBondIter ##############

package Chemistry::OpenBabel::_OBAtomBondIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBAtomBondIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBAtomBondIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBAtomBondIter_good;
*inc = *Chemistry::OpenBabelc::_OBAtomBondIter_inc;
*deref = *Chemistry::OpenBabelc::_OBAtomBondIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBAtomBondIter___ref__;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBAtomBondIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBAtomBondIter_Visit_set;
*SetIdx = *Chemistry::OpenBabelc::_OBAtomBondIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBAtomBondIter_SetId;
*SetBondOrder = *Chemistry::OpenBabelc::_OBAtomBondIter_SetBondOrder;
*SetBegin = *Chemistry::OpenBabelc::_OBAtomBondIter_SetBegin;
*SetEnd = *Chemistry::OpenBabelc::_OBAtomBondIter_SetEnd;
*SetParent = *Chemistry::OpenBabelc::_OBAtomBondIter_SetParent;
*SetLength = *Chemistry::OpenBabelc::_OBAtomBondIter_SetLength;
*Set = *Chemistry::OpenBabelc::_OBAtomBondIter_Set;
*SetAromatic = *Chemistry::OpenBabelc::_OBAtomBondIter_SetAromatic;
*SetWedge = *Chemistry::OpenBabelc::_OBAtomBondIter_SetWedge;
*SetHash = *Chemistry::OpenBabelc::_OBAtomBondIter_SetHash;
*SetWedgeOrHash = *Chemistry::OpenBabelc::_OBAtomBondIter_SetWedgeOrHash;
*SetInRing = *Chemistry::OpenBabelc::_OBAtomBondIter_SetInRing;
*SetClosure = *Chemistry::OpenBabelc::_OBAtomBondIter_SetClosure;
*GetIdx = *Chemistry::OpenBabelc::_OBAtomBondIter_GetIdx;
*GetId = *Chemistry::OpenBabelc::_OBAtomBondIter_GetId;
*GetBondOrder = *Chemistry::OpenBabelc::_OBAtomBondIter_GetBondOrder;
*GetFlags = *Chemistry::OpenBabelc::_OBAtomBondIter_GetFlags;
*GetBeginAtomIdx = *Chemistry::OpenBabelc::_OBAtomBondIter_GetBeginAtomIdx;
*GetEndAtomIdx = *Chemistry::OpenBabelc::_OBAtomBondIter_GetEndAtomIdx;
*GetBeginAtom = *Chemistry::OpenBabelc::_OBAtomBondIter_GetBeginAtom;
*GetEndAtom = *Chemistry::OpenBabelc::_OBAtomBondIter_GetEndAtom;
*GetNbrAtom = *Chemistry::OpenBabelc::_OBAtomBondIter_GetNbrAtom;
*GetParent = *Chemistry::OpenBabelc::_OBAtomBondIter_GetParent;
*GetEquibLength = *Chemistry::OpenBabelc::_OBAtomBondIter_GetEquibLength;
*GetLength = *Chemistry::OpenBabelc::_OBAtomBondIter_GetLength;
*GetNbrAtomIdx = *Chemistry::OpenBabelc::_OBAtomBondIter_GetNbrAtomIdx;
*FindSmallestRing = *Chemistry::OpenBabelc::_OBAtomBondIter_FindSmallestRing;
*IsAromatic = *Chemistry::OpenBabelc::_OBAtomBondIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBAtomBondIter_IsInRing;
*IsRotor = *Chemistry::OpenBabelc::_OBAtomBondIter_IsRotor;
*IsPeriodic = *Chemistry::OpenBabelc::_OBAtomBondIter_IsPeriodic;
*IsAmide = *Chemistry::OpenBabelc::_OBAtomBondIter_IsAmide;
*IsPrimaryAmide = *Chemistry::OpenBabelc::_OBAtomBondIter_IsPrimaryAmide;
*IsSecondaryAmide = *Chemistry::OpenBabelc::_OBAtomBondIter_IsSecondaryAmide;
*IsTertiaryAmide = *Chemistry::OpenBabelc::_OBAtomBondIter_IsTertiaryAmide;
*IsEster = *Chemistry::OpenBabelc::_OBAtomBondIter_IsEster;
*IsCarbonyl = *Chemistry::OpenBabelc::_OBAtomBondIter_IsCarbonyl;
*IsClosure = *Chemistry::OpenBabelc::_OBAtomBondIter_IsClosure;
*IsWedge = *Chemistry::OpenBabelc::_OBAtomBondIter_IsWedge;
*IsHash = *Chemistry::OpenBabelc::_OBAtomBondIter_IsHash;
*IsWedgeOrHash = *Chemistry::OpenBabelc::_OBAtomBondIter_IsWedgeOrHash;
*IsCisOrTrans = *Chemistry::OpenBabelc::_OBAtomBondIter_IsCisOrTrans;
*IsDoubleBondGeometry = *Chemistry::OpenBabelc::_OBAtomBondIter_IsDoubleBondGeometry;
*Clear = *Chemistry::OpenBabelc::_OBAtomBondIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBAtomBondIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBAtomBondIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBAtomBondIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBAtomBondIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBAtomBondIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBAtomBondIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBAtomBondIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBAtomBondIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBAtomBondIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBAtomBondIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBAtomBondIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBAtomBondIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::OBResidueIter ##############

package Chemistry::OpenBabel::OBResidueIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new_OBResidueIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete_OBResidueIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::OBResidueIter_good;
*inc = *Chemistry::OpenBabelc::OBResidueIter_inc;
*deref = *Chemistry::OpenBabelc::OBResidueIter_deref;
*__ref__ = *Chemistry::OpenBabelc::OBResidueIter___ref__;
*AddAtom = *Chemistry::OpenBabelc::OBResidueIter_AddAtom;
*InsertAtom = *Chemistry::OpenBabelc::OBResidueIter_InsertAtom;
*RemoveAtom = *Chemistry::OpenBabelc::OBResidueIter_RemoveAtom;
*SetName = *Chemistry::OpenBabelc::OBResidueIter_SetName;
*SetNum = *Chemistry::OpenBabelc::OBResidueIter_SetNum;
*SetChain = *Chemistry::OpenBabelc::OBResidueIter_SetChain;
*SetChainNum = *Chemistry::OpenBabelc::OBResidueIter_SetChainNum;
*SetIdx = *Chemistry::OpenBabelc::OBResidueIter_SetIdx;
*SetInsertionCode = *Chemistry::OpenBabelc::OBResidueIter_SetInsertionCode;
*SetAtomID = *Chemistry::OpenBabelc::OBResidueIter_SetAtomID;
*SetHetAtom = *Chemistry::OpenBabelc::OBResidueIter_SetHetAtom;
*SetSerialNum = *Chemistry::OpenBabelc::OBResidueIter_SetSerialNum;
*GetName = *Chemistry::OpenBabelc::OBResidueIter_GetName;
*GetNum = *Chemistry::OpenBabelc::OBResidueIter_GetNum;
*GetNumString = *Chemistry::OpenBabelc::OBResidueIter_GetNumString;
*GetNumAtoms = *Chemistry::OpenBabelc::OBResidueIter_GetNumAtoms;
*GetChain = *Chemistry::OpenBabelc::OBResidueIter_GetChain;
*GetChainNum = *Chemistry::OpenBabelc::OBResidueIter_GetChainNum;
*GetIdx = *Chemistry::OpenBabelc::OBResidueIter_GetIdx;
*GetResKey = *Chemistry::OpenBabelc::OBResidueIter_GetResKey;
*GetAtoms = *Chemistry::OpenBabelc::OBResidueIter_GetAtoms;
*GetBonds = *Chemistry::OpenBabelc::OBResidueIter_GetBonds;
*GetAtomID = *Chemistry::OpenBabelc::OBResidueIter_GetAtomID;
*GetSerialNum = *Chemistry::OpenBabelc::OBResidueIter_GetSerialNum;
*GetInsertionCode = *Chemistry::OpenBabelc::OBResidueIter_GetInsertionCode;
*GetAminoAcidProperty = *Chemistry::OpenBabelc::OBResidueIter_GetAminoAcidProperty;
*GetAtomProperty = *Chemistry::OpenBabelc::OBResidueIter_GetAtomProperty;
*GetResidueProperty = *Chemistry::OpenBabelc::OBResidueIter_GetResidueProperty;
*IsHetAtom = *Chemistry::OpenBabelc::OBResidueIter_IsHetAtom;
*IsResidueType = *Chemistry::OpenBabelc::OBResidueIter_IsResidueType;
*BeginAtoms = *Chemistry::OpenBabelc::OBResidueIter_BeginAtoms;
*EndAtoms = *Chemistry::OpenBabelc::OBResidueIter_EndAtoms;
*BeginAtom = *Chemistry::OpenBabelc::OBResidueIter_BeginAtom;
*NextAtom = *Chemistry::OpenBabelc::OBResidueIter_NextAtom;
*Clear = *Chemistry::OpenBabelc::OBResidueIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::OBResidueIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::OBResidueIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::OBResidueIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::OBResidueIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::OBResidueIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::OBResidueIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::OBResidueIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::OBResidueIter_DataSize;
*GetData = *Chemistry::OpenBabelc::OBResidueIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::OBResidueIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::OBResidueIter_BeginData;
*EndData = *Chemistry::OpenBabelc::OBResidueIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBResidueAtomIter ##############

package Chemistry::OpenBabel::_OBResidueAtomIter;
use overload
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBResidueAtomIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBResidueAtomIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBResidueAtomIter_good;
*inc = *Chemistry::OpenBabelc::_OBResidueAtomIter_inc;
*deref = *Chemistry::OpenBabelc::_OBResidueAtomIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBResidueAtomIter___ref__;
*swig_Visit_get = *Chemistry::OpenBabelc::_OBResidueAtomIter_Visit_get;
*swig_Visit_set = *Chemistry::OpenBabelc::_OBResidueAtomIter_Visit_set;
*__eq__ = *Chemistry::OpenBabelc::_OBResidueAtomIter___eq__;
*Duplicate = *Chemistry::OpenBabelc::_OBResidueAtomIter_Duplicate;
*SetIdx = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetIdx;
*SetId = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetId;
*SetHyb = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetHyb;
*SetAtomicNum = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetAtomicNum;
*SetIsotope = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetIsotope;
*SetImplicitHCount = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetImplicitHCount;
*SetFormalCharge = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetFormalCharge;
*SetSpinMultiplicity = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetSpinMultiplicity;
*SetType = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetType;
*SetPartialCharge = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetPartialCharge;
*SetVector = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetVector;
*SetCoordPtr = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetCoordPtr;
*SetResidue = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetResidue;
*SetParent = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetParent;
*SetAromatic = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetAromatic;
*SetInRing = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetInRing;
*ClearCoordPtr = *Chemistry::OpenBabelc::_OBResidueAtomIter_ClearCoordPtr;
*GetFormalCharge = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetFormalCharge;
*GetAtomicNum = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetAtomicNum;
*GetIsotope = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetIsotope;
*GetSpinMultiplicity = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetSpinMultiplicity;
*GetAtomicMass = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetAtomicMass;
*GetExactMass = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetExactMass;
*GetIdx = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetIdx;
*GetIndex = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetIndex;
*GetId = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetId;
*GetCoordinateIdx = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetCoordinateIdx;
*GetExplicitDegree = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetExplicitDegree;
*GetTotalDegree = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetTotalDegree;
*GetExplicitValence = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetExplicitValence;
*GetTotalValence = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetTotalValence;
*GetHyb = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetHyb;
*GetImplicitHCount = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetImplicitHCount;
*GetHvyDegree = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetHvyDegree;
*GetHeteroDegree = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetHeteroDegree;
*GetType = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetType;
*GetX = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetX;
*GetY = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetY;
*GetZ = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetZ;
*x = *Chemistry::OpenBabelc::_OBResidueAtomIter_x;
*y = *Chemistry::OpenBabelc::_OBResidueAtomIter_y;
*z = *Chemistry::OpenBabelc::_OBResidueAtomIter_z;
*GetCoordinate = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetCoordinate;
*GetVector = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetVector;
*GetPartialCharge = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetPartialCharge;
*GetResidue = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetResidue;
*GetParent = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetParent;
*GetNewBondVector = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetNewBondVector;
*GetBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetBond;
*BeginBonds = *Chemistry::OpenBabelc::_OBResidueAtomIter_BeginBonds;
*EndBonds = *Chemistry::OpenBabelc::_OBResidueAtomIter_EndBonds;
*BeginBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_BeginBond;
*NextBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_NextBond;
*BeginNbrAtom = *Chemistry::OpenBabelc::_OBResidueAtomIter_BeginNbrAtom;
*NextNbrAtom = *Chemistry::OpenBabelc::_OBResidueAtomIter_NextNbrAtom;
*GetDistance = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetDistance;
*GetAngle = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetAngle;
*NewResidue = *Chemistry::OpenBabelc::_OBResidueAtomIter_NewResidue;
*AddResidue = *Chemistry::OpenBabelc::_OBResidueAtomIter_AddResidue;
*DeleteResidue = *Chemistry::OpenBabelc::_OBResidueAtomIter_DeleteResidue;
*AddBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_AddBond;
*InsertBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_InsertBond;
*DeleteBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_DeleteBond;
*ClearBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_ClearBond;
*HtoMethyl = *Chemistry::OpenBabelc::_OBResidueAtomIter_HtoMethyl;
*SetHybAndGeom = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetHybAndGeom;
*CountFreeOxygens = *Chemistry::OpenBabelc::_OBResidueAtomIter_CountFreeOxygens;
*CountFreeSulfurs = *Chemistry::OpenBabelc::_OBResidueAtomIter_CountFreeSulfurs;
*ExplicitHydrogenCount = *Chemistry::OpenBabelc::_OBResidueAtomIter_ExplicitHydrogenCount;
*MemberOfRingCount = *Chemistry::OpenBabelc::_OBResidueAtomIter_MemberOfRingCount;
*MemberOfRingSize = *Chemistry::OpenBabelc::_OBResidueAtomIter_MemberOfRingSize;
*CountRingBonds = *Chemistry::OpenBabelc::_OBResidueAtomIter_CountRingBonds;
*SmallestBondAngle = *Chemistry::OpenBabelc::_OBResidueAtomIter_SmallestBondAngle;
*AverageBondAngle = *Chemistry::OpenBabelc::_OBResidueAtomIter_AverageBondAngle;
*LewisAcidBaseCounts = *Chemistry::OpenBabelc::_OBResidueAtomIter_LewisAcidBaseCounts;
*HasResidue = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasResidue;
*IsHetAtom = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsHetAtom;
*IsElement = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsElement;
*IsAromatic = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsAromatic;
*IsInRing = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsInRing;
*IsInRingSize = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsInRingSize;
*IsHeteroatom = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsHeteroatom;
*IsConnected = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsConnected;
*IsOneThree = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsOneThree;
*IsOneFour = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsOneFour;
*IsCarboxylOxygen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsCarboxylOxygen;
*IsPhosphateOxygen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsPhosphateOxygen;
*IsSulfateOxygen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsSulfateOxygen;
*IsNitroOxygen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsNitroOxygen;
*IsAmideNitrogen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsAmideNitrogen;
*IsPolarHydrogen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsPolarHydrogen;
*IsNonPolarHydrogen = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsNonPolarHydrogen;
*IsAromaticNOxide = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsAromaticNOxide;
*IsChiral = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsChiral;
*IsPeriodic = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsPeriodic;
*IsAxial = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsAxial;
*IsHbondAcceptor = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsHbondAcceptor;
*IsHbondAcceptorSimple = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsHbondAcceptorSimple;
*IsHbondDonor = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsHbondDonor;
*IsHbondDonorH = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsHbondDonorH;
*IsMetal = *Chemistry::OpenBabelc::_OBResidueAtomIter_IsMetal;
*HasAlphaBetaUnsat = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasAlphaBetaUnsat;
*HasBondOfOrder = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasBondOfOrder;
*CountBondsOfOrder = *Chemistry::OpenBabelc::_OBResidueAtomIter_CountBondsOfOrder;
*HighestBondOrder = *Chemistry::OpenBabelc::_OBResidueAtomIter_HighestBondOrder;
*HasNonSingleBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasNonSingleBond;
*HasSingleBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasSingleBond;
*HasDoubleBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasDoubleBond;
*HasAromaticBond = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasAromaticBond;
*MatchesSMARTS = *Chemistry::OpenBabelc::_OBResidueAtomIter_MatchesSMARTS;
*Clear = *Chemistry::OpenBabelc::_OBResidueAtomIter_Clear;
*DoTransformations = *Chemistry::OpenBabelc::_OBResidueAtomIter_DoTransformations;
*ClassDescription = *Chemistry::OpenBabelc::_OBResidueAtomIter_ClassDescription;
*GetTitle = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetTitle;
*SetTitle = *Chemistry::OpenBabelc::_OBResidueAtomIter_SetTitle;
*HasData = *Chemistry::OpenBabelc::_OBResidueAtomIter_HasData;
*DeleteData = *Chemistry::OpenBabelc::_OBResidueAtomIter_DeleteData;
*CloneData = *Chemistry::OpenBabelc::_OBResidueAtomIter_CloneData;
*DataSize = *Chemistry::OpenBabelc::_OBResidueAtomIter_DataSize;
*GetData = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetData;
*GetAllData = *Chemistry::OpenBabelc::_OBResidueAtomIter_GetAllData;
*BeginData = *Chemistry::OpenBabelc::_OBResidueAtomIter_BeginData;
*EndData = *Chemistry::OpenBabelc::_OBResidueAtomIter_EndData;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolAngleIter ##############

package Chemistry::OpenBabel::_OBMolAngleIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolAngleIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolAngleIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolAngleIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolAngleIter_inc;
*__ref__ = *Chemistry::OpenBabelc::_OBMolAngleIter___ref__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolTorsionIter ##############

package Chemistry::OpenBabel::_OBMolTorsionIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolTorsionIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolTorsionIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolTorsionIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolTorsionIter_inc;
*__ref__ = *Chemistry::OpenBabelc::_OBMolTorsionIter___ref__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolPairIter ##############

package Chemistry::OpenBabel::_OBMolPairIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolPairIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolPairIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolPairIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolPairIter_inc;
*__ref__ = *Chemistry::OpenBabelc::_OBMolPairIter___ref__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Chemistry::OpenBabel::_OBMolRingIter ##############

package Chemistry::OpenBabel::_OBMolRingIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Chemistry::OpenBabel );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Chemistry::OpenBabelc::new__OBMolRingIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Chemistry::OpenBabelc::delete__OBMolRingIter($self);
        delete $OWNER{$self};
    }
}

*good = *Chemistry::OpenBabelc::_OBMolRingIter_good;
*inc = *Chemistry::OpenBabelc::_OBMolRingIter_inc;
*deref = *Chemistry::OpenBabelc::_OBMolRingIter_deref;
*__ref__ = *Chemistry::OpenBabelc::_OBMolRingIter___ref__;
*swig_ring_id_get = *Chemistry::OpenBabelc::_OBMolRingIter_ring_id_get;
*swig_ring_id_set = *Chemistry::OpenBabelc::_OBMolRingIter_ring_id_set;
*swig__path_get = *Chemistry::OpenBabelc::_OBMolRingIter__path_get;
*swig__path_set = *Chemistry::OpenBabelc::_OBMolRingIter__path_set;
*swig__pathset_get = *Chemistry::OpenBabelc::_OBMolRingIter__pathset_get;
*swig__pathset_set = *Chemistry::OpenBabelc::_OBMolRingIter__pathset_set;
*Size = *Chemistry::OpenBabelc::_OBMolRingIter_Size;
*PathSize = *Chemistry::OpenBabelc::_OBMolRingIter_PathSize;
*IsAromatic = *Chemistry::OpenBabelc::_OBMolRingIter_IsAromatic;
*SetType = *Chemistry::OpenBabelc::_OBMolRingIter_SetType;
*GetType = *Chemistry::OpenBabelc::_OBMolRingIter_GetType;
*GetRootAtom = *Chemistry::OpenBabelc::_OBMolRingIter_GetRootAtom;
*IsMember = *Chemistry::OpenBabelc::_OBMolRingIter_IsMember;
*IsInRing = *Chemistry::OpenBabelc::_OBMolRingIter_IsInRing;
*SetParent = *Chemistry::OpenBabelc::_OBMolRingIter_SetParent;
*GetParent = *Chemistry::OpenBabelc::_OBMolRingIter_GetParent;
*findCenterAndNormal = *Chemistry::OpenBabelc::_OBMolRingIter_findCenterAndNormal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Chemistry::OpenBabel;


my %__ttab_hash;
tie %__ttab_hash,"Chemistry::OpenBabel::OBTypeTable", $Chemistry::OpenBabelc::ttab;
$ttab= \%__ttab_hash;
bless $ttab, Chemistry::OpenBabel::OBTypeTable;

my %__resdat_hash;
tie %__resdat_hash,"Chemistry::OpenBabel::OBResidueData", $Chemistry::OpenBabelc::resdat;
$resdat= \%__resdat_hash;
bless $resdat, Chemistry::OpenBabel::OBResidueData;
*M_PI = *Chemistry::OpenBabelc::M_PI;
*RAD_TO_DEG = *Chemistry::OpenBabelc::RAD_TO_DEG;
*DEG_TO_RAD = *Chemistry::OpenBabelc::DEG_TO_RAD;

my %__VZero_hash;
tie %__VZero_hash,"Chemistry::OpenBabel::vector3", $Chemistry::OpenBabelc::VZero;
$VZero= \%__VZero_hash;
bless $VZero, Chemistry::OpenBabel::vector3;

my %__VX_hash;
tie %__VX_hash,"Chemistry::OpenBabel::vector3", $Chemistry::OpenBabelc::VX;
$VX= \%__VX_hash;
bless $VX, Chemistry::OpenBabel::vector3;

my %__VY_hash;
tie %__VY_hash,"Chemistry::OpenBabel::vector3", $Chemistry::OpenBabelc::VY;
$VY= \%__VY_hash;
bless $VY, Chemistry::OpenBabel::vector3;

my %__VZ_hash;
tie %__VZ_hash,"Chemistry::OpenBabel::vector3", $Chemistry::OpenBabelc::VZ;
$VZ= \%__VZ_hash;
bless $VZ, Chemistry::OpenBabel::vector3;
*SETWORD = *Chemistry::OpenBabelc::SETWORD;
*WORDROLL = *Chemistry::OpenBabelc::WORDROLL;
*WORDMASK = *Chemistry::OpenBabelc::WORDMASK;
*STARTWORDS = *Chemistry::OpenBabelc::STARTWORDS;
*UndefinedData = *Chemistry::OpenBabelc::UndefinedData;
*PairData = *Chemistry::OpenBabelc::PairData;
*EnergyData = *Chemistry::OpenBabelc::EnergyData;
*CommentData = *Chemistry::OpenBabelc::CommentData;
*ConformerData = *Chemistry::OpenBabelc::ConformerData;
*ExternalBondData = *Chemistry::OpenBabelc::ExternalBondData;
*RotamerList = *Chemistry::OpenBabelc::RotamerList;
*VirtualBondData = *Chemistry::OpenBabelc::VirtualBondData;
*RingData = *Chemistry::OpenBabelc::RingData;
*TorsionData = *Chemistry::OpenBabelc::TorsionData;
*AngleData = *Chemistry::OpenBabelc::AngleData;
*SerialNums = *Chemistry::OpenBabelc::SerialNums;
*UnitCell = *Chemistry::OpenBabelc::UnitCell;
*SpinData = *Chemistry::OpenBabelc::SpinData;
*ChargeData = *Chemistry::OpenBabelc::ChargeData;
*SymmetryData = *Chemistry::OpenBabelc::SymmetryData;
*OccupationData = *Chemistry::OpenBabelc::OccupationData;
*DensityData = *Chemistry::OpenBabelc::DensityData;
*ElectronicData = *Chemistry::OpenBabelc::ElectronicData;
*VibrationData = *Chemistry::OpenBabelc::VibrationData;
*RotationData = *Chemistry::OpenBabelc::RotationData;
*NuclearData = *Chemistry::OpenBabelc::NuclearData;
*SetData = *Chemistry::OpenBabelc::SetData;
*GridData = *Chemistry::OpenBabelc::GridData;
*VectorData = *Chemistry::OpenBabelc::VectorData;
*MatrixData = *Chemistry::OpenBabelc::MatrixData;
*StereoData = *Chemistry::OpenBabelc::StereoData;
*DOSData = *Chemistry::OpenBabelc::DOSData;
*ElectronicTransitionData = *Chemistry::OpenBabelc::ElectronicTransitionData;
*CustomData0 = *Chemistry::OpenBabelc::CustomData0;
*CustomData1 = *Chemistry::OpenBabelc::CustomData1;
*CustomData2 = *Chemistry::OpenBabelc::CustomData2;
*CustomData3 = *Chemistry::OpenBabelc::CustomData3;
*CustomData4 = *Chemistry::OpenBabelc::CustomData4;
*CustomData5 = *Chemistry::OpenBabelc::CustomData5;
*CustomData6 = *Chemistry::OpenBabelc::CustomData6;
*CustomData7 = *Chemistry::OpenBabelc::CustomData7;
*CustomData8 = *Chemistry::OpenBabelc::CustomData8;
*CustomData9 = *Chemistry::OpenBabelc::CustomData9;
*CustomData10 = *Chemistry::OpenBabelc::CustomData10;
*CustomData11 = *Chemistry::OpenBabelc::CustomData11;
*CustomData12 = *Chemistry::OpenBabelc::CustomData12;
*CustomData13 = *Chemistry::OpenBabelc::CustomData13;
*CustomData14 = *Chemistry::OpenBabelc::CustomData14;
*CustomData15 = *Chemistry::OpenBabelc::CustomData15;
*any = *Chemistry::OpenBabelc::any;
*fileformatInput = *Chemistry::OpenBabelc::fileformatInput;
*userInput = *Chemistry::OpenBabelc::userInput;
*perceived = *Chemistry::OpenBabelc::perceived;
*external = *Chemistry::OpenBabelc::external;
*_local = *Chemistry::OpenBabelc::_local;
*obError = *Chemistry::OpenBabelc::obError;
*obWarning = *Chemistry::OpenBabelc::obWarning;
*obInfo = *Chemistry::OpenBabelc::obInfo;
*obAuditMsg = *Chemistry::OpenBabelc::obAuditMsg;
*obDebug = *Chemistry::OpenBabelc::obDebug;
*always = *Chemistry::OpenBabelc::always;
*onceOnly = *Chemistry::OpenBabelc::onceOnly;

my %__obErrorLog_hash;
tie %__obErrorLog_hash,"Chemistry::OpenBabel::OBMessageHandler", $Chemistry::OpenBabelc::obErrorLog;
$obErrorLog= \%__obErrorLog_hash;
bless $obErrorLog, Chemistry::OpenBabel::OBMessageHandler;
*NOTREADABLE = *Chemistry::OpenBabelc::NOTREADABLE;
*READONEONLY = *Chemistry::OpenBabelc::READONEONLY;
*READBINARY = *Chemistry::OpenBabelc::READBINARY;
*ZEROATOMSOK = *Chemistry::OpenBabelc::ZEROATOMSOK;
*NOTWRITABLE = *Chemistry::OpenBabelc::NOTWRITABLE;
*WRITEONEONLY = *Chemistry::OpenBabelc::WRITEONEONLY;
*WRITEBINARY = *Chemistry::OpenBabelc::WRITEBINARY;
*READXML = *Chemistry::OpenBabelc::READXML;
*DEPICTION2D = *Chemistry::OpenBabelc::DEPICTION2D;
*DEFAULTFORMAT = *Chemistry::OpenBabelc::DEFAULTFORMAT;
*MAXSETNO = *Chemistry::OpenBabelc::MAXSETNO;
*MAXELEM = *Chemistry::OpenBabelc::MAXELEM;
*MAXRES = *Chemistry::OpenBabelc::MAXRES;
*AA_ALA = *Chemistry::OpenBabelc::AA_ALA;
*AA_GLY = *Chemistry::OpenBabelc::AA_GLY;
*AA_LEU = *Chemistry::OpenBabelc::AA_LEU;
*AA_SER = *Chemistry::OpenBabelc::AA_SER;
*AA_VAL = *Chemistry::OpenBabelc::AA_VAL;
*AA_THR = *Chemistry::OpenBabelc::AA_THR;
*AA_LYS = *Chemistry::OpenBabelc::AA_LYS;
*AA_ASP = *Chemistry::OpenBabelc::AA_ASP;
*AA_ILE = *Chemistry::OpenBabelc::AA_ILE;
*AA_ASN = *Chemistry::OpenBabelc::AA_ASN;
*AA_GLU = *Chemistry::OpenBabelc::AA_GLU;
*AA_PRO = *Chemistry::OpenBabelc::AA_PRO;
*AA_ARG = *Chemistry::OpenBabelc::AA_ARG;
*AA_PHE = *Chemistry::OpenBabelc::AA_PHE;
*AA_GLN = *Chemistry::OpenBabelc::AA_GLN;
*AA_TYR = *Chemistry::OpenBabelc::AA_TYR;
*AA_HIS = *Chemistry::OpenBabelc::AA_HIS;
*AA_CYS = *Chemistry::OpenBabelc::AA_CYS;
*AA_MET = *Chemistry::OpenBabelc::AA_MET;
*AA_TRP = *Chemistry::OpenBabelc::AA_TRP;
*ACIDIC = *Chemistry::OpenBabelc::ACIDIC;
*ACYCLIC = *Chemistry::OpenBabelc::ACYCLIC;
*ALIPHATIC = *Chemistry::OpenBabelc::ALIPHATIC;
*AROMATIC = *Chemistry::OpenBabelc::AROMATIC;
*BASIC = *Chemistry::OpenBabelc::BASIC;
*BURIED = *Chemistry::OpenBabelc::BURIED;
*CHARGED = *Chemistry::OpenBabelc::CHARGED;
*CYCLIC = *Chemistry::OpenBabelc::CYCLIC;
*HYDROPHOBIC = *Chemistry::OpenBabelc::HYDROPHOBIC;
*LARGE = *Chemistry::OpenBabelc::LARGE;
*MEDIUM = *Chemistry::OpenBabelc::MEDIUM;
*NEGATIVE = *Chemistry::OpenBabelc::NEGATIVE;
*NEUTRAL = *Chemistry::OpenBabelc::NEUTRAL;
*POLAR = *Chemistry::OpenBabelc::POLAR;
*POSITIVE = *Chemistry::OpenBabelc::POSITIVE;
*SMALL = *Chemistry::OpenBabelc::SMALL;
*SURFACE = *Chemistry::OpenBabelc::SURFACE;
*ALPHA_CARBON = *Chemistry::OpenBabelc::ALPHA_CARBON;
*AMINO_BACKBONE = *Chemistry::OpenBabelc::AMINO_BACKBONE;
*BACKBONE = *Chemistry::OpenBabelc::BACKBONE;
*CYSTEINE_SULPHUR = *Chemistry::OpenBabelc::CYSTEINE_SULPHUR;
*LIGAND = *Chemistry::OpenBabelc::LIGAND;
*NUCLEIC_BACKBONE = *Chemistry::OpenBabelc::NUCLEIC_BACKBONE;
*SHAPELY_BACKBONE = *Chemistry::OpenBabelc::SHAPELY_BACKBONE;
*SHAPELY_SPECIAL = *Chemistry::OpenBabelc::SHAPELY_SPECIAL;
*SIDECHAIN = *Chemistry::OpenBabelc::SIDECHAIN;
*SUGAR_PHOSPHATE = *Chemistry::OpenBabelc::SUGAR_PHOSPHATE;
*ALA = *Chemistry::OpenBabelc::ALA;
*GLY = *Chemistry::OpenBabelc::GLY;
*LEU = *Chemistry::OpenBabelc::LEU;
*SER = *Chemistry::OpenBabelc::SER;
*VAL = *Chemistry::OpenBabelc::VAL;
*LYS = *Chemistry::OpenBabelc::LYS;
*ASP = *Chemistry::OpenBabelc::ASP;
*ILE = *Chemistry::OpenBabelc::ILE;
*ASN = *Chemistry::OpenBabelc::ASN;
*GLU = *Chemistry::OpenBabelc::GLU;
*PRO = *Chemistry::OpenBabelc::PRO;
*ARG = *Chemistry::OpenBabelc::ARG;
*PHE = *Chemistry::OpenBabelc::PHE;
*GLN = *Chemistry::OpenBabelc::GLN;
*TYR = *Chemistry::OpenBabelc::TYR;
*HIS = *Chemistry::OpenBabelc::HIS;
*CYS = *Chemistry::OpenBabelc::CYS;
*MET = *Chemistry::OpenBabelc::MET;
*TRP = *Chemistry::OpenBabelc::TRP;
*ASX = *Chemistry::OpenBabelc::ASX;
*GLX = *Chemistry::OpenBabelc::GLX;
*PCA = *Chemistry::OpenBabelc::PCA;
*HYP = *Chemistry::OpenBabelc::HYP;
*A = *Chemistry::OpenBabelc::A;
*C = *Chemistry::OpenBabelc::C;
*G = *Chemistry::OpenBabelc::G;
*T = *Chemistry::OpenBabelc::T;
*U = *Chemistry::OpenBabelc::U;
*UPLUS = *Chemistry::OpenBabelc::UPLUS;
*I = *Chemistry::OpenBabelc::I;
*_1MA = *Chemistry::OpenBabelc::_1MA;
*_5MC = *Chemistry::OpenBabelc::_5MC;
*OMC = *Chemistry::OpenBabelc::OMC;
*_1MG = *Chemistry::OpenBabelc::_1MG;
*_2MG = *Chemistry::OpenBabelc::_2MG;
*M2G = *Chemistry::OpenBabelc::M2G;
*_7MG = *Chemistry::OpenBabelc::_7MG;
*OMG = *Chemistry::OpenBabelc::OMG;
*YG = *Chemistry::OpenBabelc::YG;
*H2U = *Chemistry::OpenBabelc::H2U;
*_5MU = *Chemistry::OpenBabelc::_5MU;
*PSU = *Chemistry::OpenBabelc::PSU;
*UNK = *Chemistry::OpenBabelc::UNK;
*ACE = *Chemistry::OpenBabelc::ACE;
*FOR = *Chemistry::OpenBabelc::FOR;
*HOH = *Chemistry::OpenBabelc::HOH;
*DOD = *Chemistry::OpenBabelc::DOD;
*SO4 = *Chemistry::OpenBabelc::SO4;
*PO4 = *Chemistry::OpenBabelc::PO4;
*NAD = *Chemistry::OpenBabelc::NAD;
*COA = *Chemistry::OpenBabelc::COA;
*NAP = *Chemistry::OpenBabelc::NAP;
*NDP = *Chemistry::OpenBabelc::NDP;
*AMINO = *Chemistry::OpenBabelc::AMINO;
*AMINO_NUCLEO = *Chemistry::OpenBabelc::AMINO_NUCLEO;
*COENZYME = *Chemistry::OpenBabelc::COENZYME;
*ION = *Chemistry::OpenBabelc::ION;
*NUCLEO = *Chemistry::OpenBabelc::NUCLEO;
*PROTEIN = *Chemistry::OpenBabelc::PROTEIN;
*PURINE = *Chemistry::OpenBabelc::PURINE;
*PYRIMIDINE = *Chemistry::OpenBabelc::PYRIMIDINE;
*SOLVENT = *Chemistry::OpenBabelc::SOLVENT;
*WATER = *Chemistry::OpenBabelc::WATER;
*OB_4RING_ATOM = *Chemistry::OpenBabelc::OB_4RING_ATOM;
*OB_3RING_ATOM = *Chemistry::OpenBabelc::OB_3RING_ATOM;
*OB_AROMATIC_ATOM = *Chemistry::OpenBabelc::OB_AROMATIC_ATOM;
*OB_RING_ATOM = *Chemistry::OpenBabelc::OB_RING_ATOM;
*OB_DONOR_ATOM = *Chemistry::OpenBabelc::OB_DONOR_ATOM;
*OB_ACCEPTOR_ATOM = *Chemistry::OpenBabelc::OB_ACCEPTOR_ATOM;
*OBATOM_TYPE_LEN = *Chemistry::OpenBabelc::OBATOM_TYPE_LEN;
*OB_AROMATIC_BOND = *Chemistry::OpenBabelc::OB_AROMATIC_BOND;
*OB_WEDGE_BOND = *Chemistry::OpenBabelc::OB_WEDGE_BOND;
*OB_HASH_BOND = *Chemistry::OpenBabelc::OB_HASH_BOND;
*OB_RING_BOND = *Chemistry::OpenBabelc::OB_RING_BOND;
*OB_CLOSURE_BOND = *Chemistry::OpenBabelc::OB_CLOSURE_BOND;
*OB_WEDGE_OR_HASH_BOND = *Chemistry::OpenBabelc::OB_WEDGE_OR_HASH_BOND;
*OB_SSSR_MOL = *Chemistry::OpenBabelc::OB_SSSR_MOL;
*OB_RINGFLAGS_MOL = *Chemistry::OpenBabelc::OB_RINGFLAGS_MOL;
*OB_AROMATIC_MOL = *Chemistry::OpenBabelc::OB_AROMATIC_MOL;
*OB_ATOMTYPES_MOL = *Chemistry::OpenBabelc::OB_ATOMTYPES_MOL;
*OB_CHIRALITY_MOL = *Chemistry::OpenBabelc::OB_CHIRALITY_MOL;
*OB_PCHARGE_MOL = *Chemistry::OpenBabelc::OB_PCHARGE_MOL;
*OB_HYBRID_MOL = *Chemistry::OpenBabelc::OB_HYBRID_MOL;
*OB_CLOSURE_MOL = *Chemistry::OpenBabelc::OB_CLOSURE_MOL;
*OB_H_ADDED_MOL = *Chemistry::OpenBabelc::OB_H_ADDED_MOL;
*OB_PH_CORRECTED_MOL = *Chemistry::OpenBabelc::OB_PH_CORRECTED_MOL;
*OB_CHAINS_MOL = *Chemistry::OpenBabelc::OB_CHAINS_MOL;
*OB_TCHARGE_MOL = *Chemistry::OpenBabelc::OB_TCHARGE_MOL;
*OB_TSPIN_MOL = *Chemistry::OpenBabelc::OB_TSPIN_MOL;
*OB_RINGTYPES_MOL = *Chemistry::OpenBabelc::OB_RINGTYPES_MOL;
*OB_PATTERN_STRUCTURE = *Chemistry::OpenBabelc::OB_PATTERN_STRUCTURE;
*OB_LSSR_MOL = *Chemistry::OpenBabelc::OB_LSSR_MOL;
*OB_ATOMSPIN_MOL = *Chemistry::OpenBabelc::OB_ATOMSPIN_MOL;
*OB_REACTION_MOL = *Chemistry::OpenBabelc::OB_REACTION_MOL;
*OB_PERIODIC_MOL = *Chemistry::OpenBabelc::OB_PERIODIC_MOL;
*OB_CURRENT_CONFORMER = *Chemistry::OpenBabelc::OB_CURRENT_CONFORMER;
*AllHydrogen = *Chemistry::OpenBabelc::AllHydrogen;
*PolarHydrogen = *Chemistry::OpenBabelc::PolarHydrogen;
*NonPolarHydrogen = *Chemistry::OpenBabelc::NonPolarHydrogen;
*NoId = *Chemistry::OpenBabelc::NoId;
*BUFF_SIZE = *Chemistry::OpenBabelc::BUFF_SIZE;
*AliasDataType = *Chemistry::OpenBabelc::AliasDataType;
*OBFF_LOGLVL_NONE = *Chemistry::OpenBabelc::OBFF_LOGLVL_NONE;
*OBFF_LOGLVL_LOW = *Chemistry::OpenBabelc::OBFF_LOGLVL_LOW;
*OBFF_LOGLVL_MEDIUM = *Chemistry::OpenBabelc::OBFF_LOGLVL_MEDIUM;
*OBFF_LOGLVL_HIGH = *Chemistry::OpenBabelc::OBFF_LOGLVL_HIGH;
*OBFF_ENERGY = *Chemistry::OpenBabelc::OBFF_ENERGY;
*OBFF_EBOND = *Chemistry::OpenBabelc::OBFF_EBOND;
*OBFF_EANGLE = *Chemistry::OpenBabelc::OBFF_EANGLE;
*OBFF_ESTRBND = *Chemistry::OpenBabelc::OBFF_ESTRBND;
*OBFF_ETORSION = *Chemistry::OpenBabelc::OBFF_ETORSION;
*OBFF_EOOP = *Chemistry::OpenBabelc::OBFF_EOOP;
*OBFF_EVDW = *Chemistry::OpenBabelc::OBFF_EVDW;
*OBFF_EELECTROSTATIC = *Chemistry::OpenBabelc::OBFF_EELECTROSTATIC;
*OBFF_CONST_IGNORE = *Chemistry::OpenBabelc::OBFF_CONST_IGNORE;
*OBFF_CONST_ATOM = *Chemistry::OpenBabelc::OBFF_CONST_ATOM;
*OBFF_CONST_ATOM_X = *Chemistry::OpenBabelc::OBFF_CONST_ATOM_X;
*OBFF_CONST_ATOM_Y = *Chemistry::OpenBabelc::OBFF_CONST_ATOM_Y;
*OBFF_CONST_ATOM_Z = *Chemistry::OpenBabelc::OBFF_CONST_ATOM_Z;
*OBFF_CONST_DISTANCE = *Chemistry::OpenBabelc::OBFF_CONST_DISTANCE;
*OBFF_CONST_ANGLE = *Chemistry::OpenBabelc::OBFF_CONST_ANGLE;
*OBFF_CONST_TORSION = *Chemistry::OpenBabelc::OBFF_CONST_TORSION;
*OBFF_CONST_CHIRAL = *Chemistry::OpenBabelc::OBFF_CONST_CHIRAL;
*OBFF_NUMERICAL_GRADIENT = *Chemistry::OpenBabelc::OBFF_NUMERICAL_GRADIENT;
*OBFF_ANALYTICAL_GRADIENT = *Chemistry::OpenBabelc::OBFF_ANALYTICAL_GRADIENT;
*KCAL_TO_KJ = *Chemistry::OpenBabelc::KCAL_TO_KJ;
*GAS_CONSTANT = *Chemistry::OpenBabelc::GAS_CONSTANT;

# http://www.perl.com/pub/a/2005/06/16/iterators.html
sub gen_iterator {
    my $iterator_function = shift;
    return sub {
        my $iter = new $iterator_function(shift);

        my ($current_state, $done);

        return sub {
            # code to calculate $next_state or $done;
            return undef if $done;
            my $next_state = $iter->deref();
            $iter->inc();
            if (!$iter->good()) {$done = 1;};
            return $current_state = $next_state;
        };
    };
}

package Chemistry::OpenBabel::OBAtomAtomIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBAtomAtomIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBAtomBondIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBAtomBondIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolAngleIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolAngleIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolAtomIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolAtomIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolAtomBFSIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolAtomBFSIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolAtomDFSIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolAtomDFSIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolBondIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolBondIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolPairIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolPairIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolRingIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolRingIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBMolTorsionIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBMolTorsionIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBResidueAtomIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBResidueAtomIter)->(shift);
   bless($self, $pkg);
}

package Chemistry::OpenBabel::OBFingerprintIter;

sub new {
   my $pkg = shift;
   my $self = Chemistry::OpenBabel::gen_iterator(Chemistry::OpenBabel::_OBFingerprintIter)->(shift);
   bless($self, $pkg);
}
1;
